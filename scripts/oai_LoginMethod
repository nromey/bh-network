#!/usr/bin/env bash
# Switch Codex CLI between ChatGPT subscription tokens and direct OpenAI API key usage.
# Usage: source scripts/oai_lkoginmethod <sub|api>
#   sub -> removes OPENAI_API_KEY so the CLI signs in with your ChatGPT Plus login
#   api -> exports OPENAI_API_KEY from OAI_PERSONAL_KEY (or DEFAULT_API_KEY) for API billing
# Note: this script must be *sourced* so it can mutate the current shell environment.
#
# Recommended secure storage:
#   1. Put your raw key in ~/api.txt (or similar) temporarily.
#   2. Encrypt it: gpg --symmetric --cipher-algo AES256 --output ~/bhn/.config/openai/openai-api.gpg ~/api.txt
#   3. (Optional) remove the plain text file.
# The script will decrypt ~/bhn/.config/openai/openai-api.gpg each time you switch to API mode.
# Tip: add `export GPG_TTY=$(tty)` to your shell profile so GPG can prompt for passphrases.

# Preserve caller shell options so sourcing doesn't leak settings.
__oai_loginmethod_restore() {
  if [[ -n "${__oai_loginmethod_prev_opts-}" ]]; then
    eval "$__oai_loginmethod_prev_opts"
    unset __oai_loginmethod_prev_opts
    trap - RETURN
  fi
}

__oai_loginmethod_prev_opts="$(set +o)"
trap '__oai_loginmethod_restore' RETURN

set -euo pipefail

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  echo "Error: source this script instead of executing it." >&2
  echo "Usage: source ${BASH_SOURCE[0]} <sub|api>" >&2
  exit 1
fi

usage() {
  cat >&2 <<USAGE
Usage: source ${BASH_SOURCE[0]} <sub|api>

sub          remove OPENAI_API_KEY and fall back to ChatGPT subscription tokens
api          export OPENAI_API_KEY so Codex CLI uses a paid OpenAI API account
encrypt-key  create or replace the encrypted API key file [--prompt] [PATH]
status       display the currently recorded login method and related state

Set OAI_PERSONAL_KEY in your shell rc file with your real API key, or
replace DEFAULT_API_KEY below. The key itself is never stored in git.
The default encrypted key path is read from $CONFIG_FILE (created automatically).
USAGE
}

# Placeholder API key. Prefer encrypted file, or set OAI_PERSONAL_KEY in your shell profile instead.
DEFAULT_API_KEY="YOUR_OPENAI_API_KEY_HERE"
HARDCODED_KEY_FILE="$HOME/bhn/.config/openai/openai-api.gpg"
DEFAULT_KEY_FILE="$HARDCODED_KEY_FILE"
CONFIG_DIR="$HOME/.config/openai"
CONFIG_FILE="${CONFIG_DIR}/loginmethod.conf"
CODEX_CONFIG_DIR="$HOME/.codex"
CODEX_CONFIG_FILE="${CODEX_CONFIG_DIR}/config.toml"
AUTH_JSON_FILE="${CODEX_CONFIG_DIR}/auth.json"
CODEX_LOGIN_METHOD=""
OAI_LOGINMETHOD_CONFIG_PRESENT=0
OAI_LOGINMETHOD_CONFIG_KEY_FILE=""


load_codex_login_method() {
  CODEX_LOGIN_METHOD=""

  if [[ -f "$CODEX_CONFIG_FILE" ]]; then
    local scope=""
    while IFS= read -r line; do
      local trimmed="${line##*( )}"
      trimmed="${trimmed%%*( )}"
      if [[ -z "$trimmed" || "$trimmed" == \#* ]]; then
        continue
      fi
      if [[ "$trimmed" == [* ]]; then
        scope="$trimmed"
        continue
      fi
      if [[ -z "$scope" && "$trimmed" == login_method\ *=* ]]; then
        local value="${trimmed#*=}"
        value="${value//\"/}"
        value="${value#${value%%[![:space:]]*}}"
        value="${value%${value##*[![:space:]]}}"
        CODEX_LOGIN_METHOD="$value"
        break
      fi
    done <"$CODEX_CONFIG_FILE"
  fi
}


load_config() {
  DEFAULT_KEY_FILE="$HARDCODED_KEY_FILE"
  OAI_LOGINMETHOD_CONFIG_PRESENT=0
  OAI_LOGINMETHOD_CONFIG_KEY_FILE=""

  if [[ -f "$CONFIG_FILE" ]]; then
    local line
    OAI_LOGINMETHOD_CONFIG_PRESENT=1
    while IFS= read -r line; do
      case "$line" in
        ''|'#'*)
          continue
          ;;
        key_file=*)
          local value="${line#key_file=}"
          if [[ -n "$value" ]]; then
            DEFAULT_KEY_FILE="$value"
          fi
          ;;
      esac
    done <"$CONFIG_FILE"
  fi

  if [[ "$DEFAULT_KEY_FILE" == ~* ]]; then
    DEFAULT_KEY_FILE="${DEFAULT_KEY_FILE/#\~/$HOME}"
  fi

  OAI_LOGINMETHOD_CONFIG_KEY_FILE="$DEFAULT_KEY_FILE"
}

save_config() {
  if [[ ! -d "$CONFIG_DIR" ]]; then
    if ! mkdir -p "$CONFIG_DIR"; then
      echo "Warning: unable to create $CONFIG_DIR to persist configuration." >&2
      return 1
    fi
  fi

  if [[ "$DEFAULT_KEY_FILE" == ~* ]]; then
    DEFAULT_KEY_FILE="${DEFAULT_KEY_FILE/#\~/$HOME}"
  fi

  {
    echo "# Codex CLI login helper configuration"
    echo "key_file=$DEFAULT_KEY_FILE"
  } >"$CONFIG_FILE"

  OAI_LOGINMETHOD_CONFIG_PRESENT=1
  OAI_LOGINMETHOD_CONFIG_KEY_FILE="$DEFAULT_KEY_FILE"
}

set_codex_login_method() {
  local desired="$1"

  if [[ -z "$desired" ]]; then
    return 0
  fi

  if [[ ! -d "$CODEX_CONFIG_DIR" ]]; then
    if ! mkdir -p "$CODEX_CONFIG_DIR"; then
      echo "Warning: unable to create $CODEX_CONFIG_DIR to update Codex login method." >&2
      return 0
    fi
  fi

  if ! python3 - "$CODEX_CONFIG_FILE" "$desired" <<'PYCODE'
import sys, pathlib
config_path = pathlib.Path(sys.argv[1])
desired = sys.argv[2]
if not config_path.exists():
    config_path.write_text(f'login_method = "{desired}"\n')
    raise SystemExit(0)
lines = config_path.read_text().splitlines()
scope = None
modified = False
new_lines = []
for line in lines:
    stripped = line.strip()
    if stripped.startswith('['):
        scope = stripped
    if scope is None and stripped.startswith('login_method'):
        new_lines.append(f'login_method = "{desired}"')
        modified = True
    else:
        new_lines.append(line)
if not modified:
    insertion = f'login_method = "{desired}"'
    idx = 0
    while idx < len(new_lines):
        stripped = new_lines[idx].strip()
        if stripped and not stripped.startswith('#') and not stripped.startswith('['):
            break
        if stripped.startswith('['):
            break
        idx += 1
    new_lines.insert(idx, insertion)
config_path.write_text("\n".join(new_lines) + "\n")
PYCODE
  then
    echo "Warning: failed to update $CODEX_CONFIG_FILE with login_method." >&2
    return 0
  fi

  CODEX_LOGIN_METHOD="$desired"
  return 0
}

load_config
load_codex_login_method


sanitize_api_key() {
  # Remove trailing whitespace/newlines that can appear after decryption or copy/paste.
  local value="$1"
  value="${value//$'\r'/}"
  value="${value//$'\n'/}"
  local leading_trim="${value%%[![:space:]]*}"
  value="${value#${leading_trim}}"
  local trailing_trim="${value##*[![:space:]]}"
  value="${value%${trailing_trim}}"
  printf '%s' "$value"
}


persist_auth_api_key() {
  local api_key="$1"
  local source="$2"

  if [[ -z "$api_key" ]]; then
    return 0
  fi

  if [[ ! -d "$CODEX_CONFIG_DIR" ]]; then
    if ! mkdir -p "$CODEX_CONFIG_DIR"; then
      echo "Warning: unable to create $CODEX_CONFIG_DIR to update auth.json." >&2
      return 0
    fi
  fi

  if ! python3 - "$AUTH_JSON_FILE" "$api_key" "$source" <<'PYCODE'
import json
import os
import pathlib
import sys

path = pathlib.Path(sys.argv[1])
api_key = sys.argv[2]
source = sys.argv[3]

data = {}
if path.exists():
    try:
        data = json.loads(path.read_text())
    except Exception:
        pass

data["OPENAI_API_KEY"] = api_key

if source:
    meta = data.setdefault("_oai_loginmethod", {})
    meta["api_key_source"] = source
else:
    data.pop("_oai_loginmethod", None)

path.write_text(json.dumps(data, indent=2) + "\n")
PYCODE
  then
    echo "Warning: failed to update $AUTH_JSON_FILE with API key metadata." >&2
    return 0
  fi

  if ! chmod 600 "$AUTH_JSON_FILE" 2>/dev/null; then
    echo "Warning: unable to set permissions on $AUTH_JSON_FILE." >&2
  fi

  return 0
}


clear_auth_api_key() {
  if [[ ! -f "$AUTH_JSON_FILE" ]]; then
    return 0
  fi

  if ! python3 - "$AUTH_JSON_FILE" <<'PYCODE'
import json
import pathlib
import sys

path = pathlib.Path(sys.argv[1])

try:
    data = json.loads(path.read_text())
except Exception:
    raise SystemExit(0)

changed = False
if data.get("OPENAI_API_KEY") is not None:
    data["OPENAI_API_KEY"] = None
    changed = True

if "_oai_loginmethod" in data:
    data.pop("_oai_loginmethod", None)
    changed = True

if changed:
    path.write_text(json.dumps(data, indent=2) + "\n")
PYCODE
  then
    echo "Warning: unable to clear API key from $AUTH_JSON_FILE." >&2
  fi

  return 0
}

use_sub() {
  unset OPENAI_API_KEY
  export OAI_LOGIN_METHOD_MODE=sub
  set_codex_login_method "subscription"
  echo "OPENAI_API_KEY unset. Codex CLI will use ChatGPT subscription authentication." >&2
}

use_api() {
  local key_file="${OAI_KEY_FILE:-$DEFAULT_KEY_FILE}"
  if [[ "$key_file" == ~* ]]; then
    key_file="${key_file/#\~/$HOME}"
  fi

  if [[ -n "${OAI_PERSONAL_KEY-}" ]]; then
    export OPENAI_API_KEY="$OAI_PERSONAL_KEY"
    export OAI_LOGIN_METHOD_MODE=api
    set_codex_login_method "api"
    echo "OPENAI_API_KEY exported from OAI_PERSONAL_KEY environment variable." >&2
    return
  fi

  if [[ -f "$key_file" ]]; then
    local key
    if ! key=$(gpg --quiet --for-your-eyes-only --decrypt "$key_file"); then
      echo "Error: failed to decrypt $key_file. Ensure GPG_TTY is set (e.g., export GPG_TTY=\$(tty)) and passphrase is correct." >&2
      return 1
    fi
    export OPENAI_API_KEY="$key"
    export OAI_LOGIN_METHOD_MODE=api
    set_codex_login_method "api"
    unset key
    echo "OPENAI_API_KEY exported via GPG-protected file at $key_file." >&2
    return
  fi

  if [[ "$DEFAULT_API_KEY" == "YOUR_OPENAI_API_KEY_HERE" ]]; then
    echo "Warning: configure an encrypted key file ($DEFAULT_KEY_FILE), set OAI_PERSONAL_KEY, or edit DEFAULT_API_KEY before using api mode." >&2
  fi
  export OPENAI_API_KEY="$DEFAULT_API_KEY"
  export OAI_LOGIN_METHOD_MODE=api
  set_codex_login_method "api"
  echo "OPENAI_API_KEY exported from DEFAULT_API_KEY placeholder." >&2
}


encrypt_key() {
  local force_prompt=0
  local override_path=""
  local persist_config=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --prompt|-p)
        force_prompt=1
        ;;
      *)
        if [[ -n "$override_path" ]]; then
          echo "Error: multiple output paths provided." >&2
          return 1
        fi
        override_path="$1"
        ;;
    esac
    shift
  done

  local key_file
  if [[ -n "$override_path" ]]; then
    key_file="$override_path"
    persist_config=1
  elif [[ -n "${OAI_KEY_FILE-}" ]]; then
    key_file="$OAI_KEY_FILE"
  else
    key_file="$DEFAULT_KEY_FILE"
  fi

  if (( ! persist_config )) && (( ! OAI_LOGINMETHOD_CONFIG_PRESENT )); then
    persist_config=1
  fi

  if [[ "$key_file" == ~* ]]; then
    key_file="${key_file/#\~/$HOME}"
  fi

  export OAI_KEY_FILE="$key_file"

  local key_dir
  key_dir=$(dirname "$key_file")

  if ! command -v gpg >/dev/null 2>&1; then
    echo "Error: gpg command not found. Install GnuPG and retry." >&2
    return 1
  fi

  if [[ ! -d "$key_dir" ]]; then
    if ! mkdir -p "$key_dir"; then
      echo "Error: unable to create directory $key_dir." >&2
      return 1
    fi
  fi

  if [[ -f "$key_file" ]]; then
    local answer=""
    read -r -p "Encrypted key $key_file already exists. Overwrite? [y/N] " answer || return 1
    local normalized="${answer,,}"
    if [[ "$normalized" != "y" && "$normalized" != "yes" ]]; then
      echo "Aborting without changes." >&2
      return 1
    fi
    if ! rm -f "$key_file"; then
      echo "Error: unable to remove existing $key_file." >&2
      return 1
    fi
  fi

  if [[ -z "${GPG_TTY-}" ]]; then
    local __gpg_tty=""
    __gpg_tty=$(tty 2>/dev/null) || __gpg_tty=""
    if [[ -n "$__gpg_tty" ]]; then
      export GPG_TTY="$__gpg_tty"
    fi
    unset __gpg_tty
  fi

  local api_key=""
  local api_source=""
  if (( ! force_prompt )); then
    if [[ -n "${OAI_PERSONAL_KEY-}" ]]; then
      api_key="$OAI_PERSONAL_KEY"
      api_source="OAI_PERSONAL_KEY"
    elif [[ -n "${OPENAI_API_KEY-}" ]]; then
      api_key="$OPENAI_API_KEY"
      api_source="OPENAI_API_KEY"
    fi
  fi

  if [[ -n "$api_key" ]]; then
    echo "Using API key from $api_source environment variable." >&2
  else
    if (( force_prompt )); then
      echo "Forcing interactive API key entry." >&2
    fi
    if ! read -r -s -p "Enter OpenAI API key: " api_key; then
      echo >&2
      echo "Error: failed to read API key input." >&2
      return 1
    fi
    echo
    if [[ -z "$api_key" ]]; then
      echo "Error: no API key entered; aborting." >&2
      return 1
    fi
  fi

  if ! printf '%s\n' "$api_key" | gpg --symmetric --cipher-algo AES256 --output "$key_file" --quiet; then
    echo "Error: gpg encryption failed." >&2
    return 1
  fi
  unset api_key api_source

  if ! chmod 600 "$key_file" 2>/dev/null; then
    echo "Warning: could not set permissions on $key_file." >&2
  fi

  DEFAULT_KEY_FILE="$key_file"

  if (( persist_config )); then
    if ! save_config; then
      echo "Warning: failed to update $CONFIG_FILE with new key path." >&2
    fi
  fi

  echo "Encrypted key saved to $key_file." >&2
}


show_status() {
  local recorded_mode="${OAI_LOGIN_METHOD_MODE-}"
  local inferred_mode

  if [[ -n "$recorded_mode" ]]; then
    echo "Recorded mode: $recorded_mode"
  fi

  if [[ -n "${OPENAI_API_KEY-}" ]]; then
    inferred_mode=api
  else
    inferred_mode=sub
  fi

  if [[ -z "$recorded_mode" ]]; then
    echo "Inferred mode: $inferred_mode (based on OPENAI_API_KEY presence)"
  elif [[ "$recorded_mode" != "$inferred_mode" ]]; then
    echo "Note: OPENAI_API_KEY suggests $inferred_mode but recorded mode is $recorded_mode"
  fi

  if [[ -n "${OPENAI_API_KEY-}" ]]; then
    echo "OPENAI_API_KEY is set in this shell"
  else
    echo "OPENAI_API_KEY is not set in this shell"
  fi

  local key_file="${OAI_KEY_FILE:-$DEFAULT_KEY_FILE}"
  if [[ "$key_file" == ~* ]]; then
    key_file="${key_file/#\~/$HOME}"
  fi
  if [[ -f "$key_file" ]]; then
    echo "Encrypted key file present at $key_file"
  else
    echo "Encrypted key file missing at $key_file"
  fi

  if [[ -f "$CONFIG_FILE" ]]; then
    echo "Config file present at $CONFIG_FILE"
    if [[ -n "$OAI_LOGINMETHOD_CONFIG_KEY_FILE" && "$OAI_LOGINMETHOD_CONFIG_KEY_FILE" != "$key_file" ]]; then
      echo "Config key_file value: $OAI_LOGINMETHOD_CONFIG_KEY_FILE"
    fi
  else
    echo "Config file missing at $CONFIG_FILE"
  fi

  if [[ -n "$CODEX_LOGIN_METHOD" ]]; then
    echo "Codex login_method in config: $CODEX_LOGIN_METHOD"
  else
    echo "Codex login_method in config: <not set>"
  fi
}



if [[ $# -lt 1 ]]; then
  usage
  return 1
fi

command="$1"
shift

case "$command" in
  sub)
    if [[ $# -gt 0 ]]; then
      echo "Error: sub does not accept additional arguments." >&2
      usage
      return 1
    fi
    use_sub
    ;;
  api)
    if [[ $# -gt 0 ]]; then
      echo "Error: api does not accept additional arguments." >&2
      usage
      return 1
    fi
    if ! use_api; then
      return 1
    fi
    ;;
  encrypt-key)
    if ! encrypt_key "$@"; then
      return 1
    fi
    ;;
  status)
    if [[ $# -gt 0 ]]; then
      echo "Error: status does not accept additional arguments." >&2
      usage
      return 1
    fi
    show_status
    ;;
  help|-h|--help)
    if [[ $# -gt 0 ]]; then
      echo "Error: help does not accept additional arguments." >&2
      usage
      return 1
    fi
    usage
    ;;
  *)
    usage
    return 1
    ;;
esac
