<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Blind Hams Nets Helper</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      }
      body {
        margin: 0;
        padding: 1.5rem;
        line-height: 1.5;
        max-width: 60rem;
      }
      h1 {
        margin-top: 0;
      }
      fieldset {
        border: 1px solid #888;
        border-radius: 0.5rem;
        padding: 1rem 1.5rem;
        margin-bottom: 1.5rem;
      }
      legend {
        font-weight: 600;
      }
      label {
        display: block;
        font-weight: 600;
        margin-top: 0.75rem;
      }
      input[type="text"],
      input[type="time"],
      input[type="number"],
      textarea,
      select {
        width: min(100%, 32rem);
        padding: 0.5rem;
        font-size: 1rem;
        margin-top: 0.25rem;
      }
      textarea {
        min-height: 6rem;
      }
      .actions {
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      }
      button {
        padding: 0.65rem 1.25rem;
        font-size: 1rem;
        border-radius: 0.4rem;
        border: 1px solid #666;
        cursor: pointer;
      }
      button.primary {
        background: #2a6ad1;
        color: #fff;
        border-color: #1d4fa0;
      }
      button.danger {
        background: #b3261e;
        color: #fff;
        border-color: #7f1b15;
      }
      .status {
        margin-top: 1rem;
        padding: 0.75rem;
        border-radius: 0.4rem;
      }
      .status.error {
        background: #fee;
        border: 1px solid #d22;
      }
      .status.success {
        background: #ecf8ed;
        border: 1px solid #2b7a2e;
      }
      #jsonPreview {
        background: #111;
        color: #fafafa;
        padding: 1rem;
        border-radius: 0.4rem;
        overflow-x: auto;
        font-family: "Fira Code", "SFMono-Regular", ui-monospace, monospace;
      }
      .hint {
        font-size: 0.9rem;
        color: #555;
      }
      .optional-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(16rem, 1fr));
      }
      .custom-field {
        border: 1px dashed #666;
        padding: 0.75rem;
        border-radius: 0.4rem;
        margin-bottom: 0.75rem;
      }
      .sr-only {
        position: absolute;
        left: -10000px;
        width: 1px;
        height: 1px;
        overflow: hidden;
      }
      .rrule-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: flex-end;
      }
      .rrule-actions input[type="text"] {
        flex: 1 1 18rem;
      }
      details.rrule-builder {
        margin-top: 1rem;
        border: 1px solid #666;
        border-radius: 0.4rem;
        padding: 0.75rem 1rem;
      }
      details.rrule-builder summary {
        font-weight: 600;
        cursor: pointer;
        list-style: none;
      }
      details.rrule-builder summary::-webkit-details-marker {
        display: none;
      }
      details.rrule-builder[open] summary {
        margin-bottom: 0.5rem;
      }
      .rrule-builder-grid {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
        margin-bottom: 0.75rem;
      }
      .weekday-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr));
        gap: 0.5rem;
      }
      .weekday-options label {
        display: flex;
        align-items: center;
        font-weight: 400;
        gap: 0.4rem;
        margin: 0;
      }
      .monthly-setpos-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr));
        gap: 0.5rem;
        margin-top: 0.5rem;
      }
      #optionalFields summary {
        cursor: pointer;
        outline: none;
      }
      #optionalFields summary::-webkit-details-marker {
        display: none;
      }
      #optionalFields[open] summary .section-heading:after {
        content: " (expanded)";
        font-size: 0.95rem;
        color: #6b7280;
      }
      #optionalFields:not([open]) summary .section-heading:after {
        content: " (collapsed)";
        font-size: 0.95rem;
        color: #6b7280;
      }
      .monthly-setpos-options label {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-weight: 500;
        margin: 0;
      }
      .rrule-description {
        margin-top: 0.5rem;
        font-size: 0.95rem;
        color: #444;
      }
      .pending-status {
        border: 1px solid #2a6ad1;
        border-radius: 0.5rem;
        padding: 1rem 1.25rem;
        margin-bottom: 1.5rem;
        background: rgba(42, 106, 209, 0.08);
      }
      .pending-status strong {
        font-weight: 700;
      }
      .pending-status .pending-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-top: 0.75rem;
        align-items: center;
      }
      .pending-status select {
        min-width: 18rem;
        flex: 0 1 auto;
      }
      .edit-controls {
        border: 1px solid #2a6ad1;
        border-radius: 0.5rem;
        padding: 1rem 1.25rem;
        margin-bottom: 1.5rem;
        background: rgba(42, 106, 209, 0.08);
      }
      .edit-controls h2 {
        margin-top: 0;
        font-size: 1.2rem;
      }
      .edit-controls .hint {
        margin-bottom: 0.75rem;
      }
      .edit-controls .search-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: flex-end;
        margin-bottom: 0.75rem;
      }
      .edit-controls .search-group label {
        margin-top: 0;
      }
      .edit-controls .search-group input[type="text"] {
        width: min(100%, 24rem);
      }
      .edit-controls .search-group button {
        margin-top: 0;
      }
      .net-list {
        width: min(100%, 24rem);
        min-height: 12rem;
        max-height: 18rem;
        padding: 0.5rem;
        font-size: 0.95rem;
        border: 1px solid #999;
        border-radius: 0.5rem;
      }
      .net-list[aria-busy="true"] {
        opacity: 0.65;
      }
      .net-list:focus {
        outline: 3px solid rgba(42, 106, 209, 0.35);
        border-color: #2a6ad1;
      }
      .net-list option {
        padding: 0.4rem 0.5rem;
      }
      .edit-notice {
        border: 1px solid #ffbf47;
        background: rgba(255, 191, 71, 0.2);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }
      .edit-notice strong {
        font-weight: 700;
      }
      .edit-notice button {
        margin-left: auto;
      }
      .pending-review {
        border: 1px solid #d1d5db;
        border-radius: 0.5rem;
        padding: 1rem 1.25rem;
        margin-bottom: 1.5rem;
        background: rgba(17, 24, 39, 0.04);
      }
      .pending-review h2 {
        margin-top: 0;
        font-size: 1.2rem;
      }
      .pending-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: grid;
        gap: 1rem;
      }
      .pending-card {
        border: 1px solid #cbd5f5;
        border-radius: 0.5rem;
        padding: 0.9rem 1.1rem;
        background: rgba(42, 106, 209, 0.05);
      }
      .pending-card h3 {
        margin: 0 0 0.35rem;
        font-size: 1.05rem;
      }
      .pending-card .meta {
        font-size: 0.9rem;
        color: #444;
        margin-bottom: 0.5rem;
      }
      .pending-change-list {
        margin: 0.5rem 0 0;
        padding-left: 0;
        list-style: none;
        display: grid;
        gap: 0.75rem;
      }
      .pending-change {
        margin: 0;
      }
      .pending-change-head {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        font-weight: 600;
      }
      .pending-change-title {
        flex: 1 1 auto;
      }
      .pending-change-open {
        flex: 0 0 auto;
      }
      .pending-change-meta {
        font-size: 0.9rem;
        color: #374151;
        margin-top: 0.25rem;
      }
      .pending-diff-list {
        list-style: disc;
        margin: 0.4rem 0 0.25rem 1.25rem;
        padding-left: 0.5rem;
      }
      .pending-diff {
        font-size: 0.95rem;
        margin-bottom: 0.25rem;
      }
      .pending-diff code {
        font-size: 0.9rem;
      }
      .pending-diff-more {
        font-size: 0.9rem;
        color: #4b5563;
      }
      .pending-card .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
      }
      .pending-empty {
        margin: 0.5rem 0 0;
        font-size: 0.95rem;
        color: #555;
      }
      .pending-meta {
        display: inline-block;
        margin-top: 0.25rem;
        font-size: 0.9rem;
        color: #374151;
      }
      .pending-note {
        margin: 0.5rem 0 0;
        font-size: 0.95rem;
        color: #1f2937;
      }
      .pending-note-inline {
        font-size: 0.9rem;
        color: #374151;
      }
      .batch-controls {
        border: 1px solid #9ca3af;
        border-radius: 0.5rem;
        padding: 1rem 1.25rem;
        margin: 1.5rem 0;
        background: rgba(17, 24, 39, 0.04);
      }
      .batch-controls h2 {
        margin: 0 0 0.5rem;
        font-size: 1.2rem;
      }
      .batch-summary {
        margin: 0 0 0.75rem;
        font-size: 0.95rem;
        color: #374151;
      }
      .batch-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: grid;
        gap: 0.75rem;
      }
      .batch-item {
        border: 1px solid #d1d5db;
        border-radius: 0.5rem;
        padding: 0.75rem 0.9rem;
        background: #fff;
      }
      .batch-item-header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        justify-content: space-between;
        font-weight: 600;
      }
      .batch-item-mode {
        font-size: 0.85rem;
        padding: 0.1rem 0.6rem;
        border-radius: 999px;
        background: rgba(42, 106, 209, 0.15);
        color: #1d4fa0;
        font-weight: 600;
      }
     .batch-item-meta {
       font-size: 0.9rem;
       color: #4b5563;
       margin-top: 0.25rem;
     }
      .batch-item-actions {
        margin-top: 0.75rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .batch-item-error {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        color: #b3261e;
      }
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(17, 24, 39, 0.45);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .modal-dialog {
        background: #fff;
        color: #111;
        max-width: 32rem;
        width: calc(100% - 2rem);
        border-radius: 0.5rem;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(17, 24, 39, 0.25);
      }
      .modal-dialog h2 {
        margin-top: 0;
        font-size: 1.35rem;
      }
      .modal-dialog textarea {
        width: 100%;
        min-height: 5rem;
        margin-top: 0.5rem;
      }
      .modal-actions {
        margin-top: 1.25rem;
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .header-meta {
        margin: 0.75rem 0 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem 1.25rem;
        align-items: center;
      }
      .header-meta .signed-in {
        margin: 0;
        font-size: 0.95rem;
        color: #1f2937;
      }
      .logout-link {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.4rem 0.85rem;
        border-radius: 0.4rem;
        border: 1px solid #1d4fa0;
        background: #2a6ad1;
        color: #fff;
        text-decoration: none;
        font-size: 0.95rem;
      }
      .logout-link:hover,
      .logout-link:focus-visible {
        background: #1d4fa0;
        outline: none;
      }
      .pending-toggle {
        margin: 0 0 1rem;
      }
      .pending-toggle button {
        margin-top: 0.5rem;
      }
      button.secondary {
        background: #f3f4f6;
        color: #111;
        border-color: #9ca3af;
      }
      button.secondary:hover,
      button.secondary:focus-visible {
        background: #e5e7eb;
      }
      .draft-banner {
        border: 1px solid #2a6ad1;
        background: rgba(42, 106, 209, 0.1);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
      }
      .draft-banner p {
        margin: 0;
      }
      .draft-banner h2 {
        margin: 0;
        font-size: 1.15rem;
      }
      .draft-banner .draft-actions {
        margin-top: 0.75rem;
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .draft-banner button {
        padding: 0.5rem 1rem;
        border-radius: 0.4rem;
        border: 1px solid #2a6ad1;
        background: #fff;
        cursor: pointer;
      }
      .draft-banner button.restore {
        background: #2a6ad1;
        color: #fff;
      }
      .autosave-status {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        color: #555;
      }
      .submission-note {
        margin-top: 1.5rem;
        max-width: 32rem;
      }
      .submission-note textarea {
        width: 100%;
        min-height: 4.5rem;
      }
      .section-heading {
        font-size: 1.35rem;
        font-weight: 600;
        margin: 1.75rem 0 0.75rem;
      }
      .section-heading:first-of-type {
        margin-top: 0;
      }
      .connections-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem 1rem;
        margin-top: 0.5rem;
      }
      .connection-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-weight: 600;
      }
      .connection-toggle input[type="checkbox"] {
        transform: scale(1.1);
      }
      .connection-section {
        margin-top: 0.75rem;
        padding: 0.75rem 1rem;
        border: 1px dashed #666;
        border-radius: 0.5rem;
        background: rgba(17, 17, 17, 0.05);
      }
      .connection-section label {
        display: block;
        font-weight: 600;
        margin-top: 0.5rem;
      }
      .connection-section input,
      .connection-section select {
        width: min(100%, 28rem);
        padding: 0.5rem;
        font-size: 1rem;
        margin-top: 0.25rem;
      }
      .field-header {
        display: flex;
        align-items: baseline;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .help-button {
        border: none;
        background: #2a6ad1;
        color: #fff;
        width: 1.75rem;
        height: 1.75rem;
        border-radius: 50%;
        font-weight: 700;
        cursor: pointer;
        font-size: 0.95rem;
      }
      .help-button:focus-visible {
        outline: 2px solid #ffbf47;
        outline-offset: 2px;
      }
      .help-button[aria-expanded="true"] {
        background: #1d4fa0;
      }
      .help-text {
        display: none;
        margin-top: 0.25rem;
      }
      .help-text[data-show="true"] {
        display: block;
      }
      .time-toggle {
        margin-top: 0.35rem;
      }
      .time-toggle button {
        font-size: 0.9rem;
        padding: 0.35rem 0.75rem;
      }
      .field-input {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .field-error {
        outline: 2px solid #d22;
        outline-offset: 2px;
      }
      #categoryOptions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1.5rem;
        margin-top: 0.5rem;
      }
      .category-option {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        margin-top: 0.35rem;
        font-weight: 500;
      }
      .manager-info {
        margin-top: 0.75rem;
        padding: 0.75rem 1rem;
        border: 1px solid #d1d5db;
        border-radius: 0.5rem;
        background: rgba(17, 24, 39, 0.04);
        font-size: 0.95rem;
        color: #1f2937;
      }
      .category-option input[type="radio"] {
        transform: scale(1.15);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Blind Hams Nets Helper</h1>
      <div class="header-meta">
        {% if pending_context.user %}
        <p class="signed-in">Signed in as <strong>{{ pending_context.user }}</strong>{% if roles %} ({{ roles|join(', ') }}){% endif %}.</p>
        {% endif %}
        <a class="logout-link" href="?logout=1">Log out</a>
      </div>
      <p>Welcome to the Net Helper — your accessible workspace for drafting nets that will appear on the Blind Hams Digital Network home page and nets listings.</p>
      <p>Fill in the form below to add nets to the queue. When you've reviewed your entries, save them and a webmaster can handle final edits, approvals, and publishing. If you spot anything that needs tweaking, just edit your draft before saving — no worries.</p>
      <p>Need to change details on a published net later on? No problem — updates will flow through the same review path so everything stays tidy and consistent.</p>
      <p class="hint">
        Fields marked with <span aria-hidden="true">*</span><span class="sr-only">required</span> are required. Draft controls live near the bottom of the page if you need to review or switch between saved work.
      </p>
    </header>

    <main>
      <div id="srAnnounce" class="sr-only" aria-live="polite" aria-atomic="true"></div>

      <section id="pendingStatus" class="pending-status" aria-live="polite">
        <h2>Draft queue</h2>
        {% if pending_context.has_pending %}
        <p><strong>Drafts waiting for review.</strong> Keep building on the newest draft below, or switch to another draft if you need to revisit earlier work.</p>
        {% else %}
        <p><strong>No drafts yet.</strong> The next save will create a fresh draft based on <code>{{ canonical_file.name }}</code>.</p>
        {% endif %}
        <div class="pending-actions">
          <label for="sourcePicker"><span class="sr-only">Draft selector</span></label>
          <select id="sourcePicker" name="sourcePicker" aria-label="Select draft or starting point">
            {% for option in source_options %}
            <option value="{{ option.key }}" data-is-pending="{{ 'true' if option.is_pending else 'false' }}" data-name="{{ option.name }}" {% if option.active %}selected{% endif %}>
              {{ option.label }}
            </option>
            {% endfor %}
          </select>
          <button type="button" id="deleteSelected" class="danger" {% if not pending_context.has_pending %}disabled{% endif %}>Delete selected draft</button>
          <button type="button" id="deleteAllPending" class="danger" {% if not pending_context.has_pending %}disabled{% endif %}>Delete all drafts</button>
        </div>
        <p class="hint" id="currentSnapshot">Currently editing from <code>{{ working_file.name }}</code></p>
        <p class="hint" id="pendingStatusHint">
          {% if pending_context.has_pending %}
          Default selection is your newest draft. Choose another to review older edits, or pick “Start fresh from {{ canonical_file.name }}” to begin a new list.
          {% else %}
          New drafts start from {{ canonical_file.name }} until you create one.
          {% endif %}
        </p>
      </section>

      <section id="editControls" class="edit-controls" aria-labelledby="editControlsHeading">
        <h2 id="editControlsHeading">Edit an existing net</h2>
        <p class="hint">Load a net from the current copy to update its details. Saving adds your changes to the draft queue for review before anything goes live.</p>
        <div class="search-group">
          <label for="netSearch">Filter by ID or name</label>
          <input type="text" id="netSearch" name="netSearch" placeholder="Type to filter…" aria-describedby="netSearchHint">
          <button type="button" id="netSearchLoadBtn" class="secondary">Load by ID</button>
        </div>
        <p class="hint" id="netSearchHint">Know the exact ID? Enter it and choose “Load by ID.” Otherwise, select from the list below.</p>
        <button type="button" class="secondary" id="showManagersBtn" aria-expanded="false" aria-controls="managerInfo">Who are the managers?</button>
        <div id="managerInfo" class="manager-info" hidden aria-hidden="true"></div>
        <select id="netList" class="net-list" size="12" aria-label="Available nets for editing" aria-describedby="netListStatus" disabled>
        </select>
        <p class="hint" id="netListStatus" aria-live="polite">Loading nets…</p>
        <div class="actions">
          <button type="button" id="netLoadSelectedBtn" class="secondary" disabled>Load selected net</button>
        </div>
      </section>

      <div class="pending-toggle">
        <button type="button" class="secondary" id="pendingToggleBtn" aria-expanded="false" aria-controls="pendingReview">
          Review drafts (none waiting)
        </button>
      </div>

      <section id="pendingReview" class="pending-review" aria-labelledby="pendingReviewHeading" hidden>
        <h2 id="pendingReviewHeading">Draft review queue</h2>
        <p class="hint" id="pendingReviewHint">Review saved drafts and publish when they're ready to go live.</p>
        <div id="pendingList" class="pending-list" aria-live="polite" aria-busy="false">
          <p class="pending-empty">Loading drafts…</p>
        </div>
      </section>

      <form id="netsForm" novalidate>
        <section id="draftBanner" class="draft-banner" hidden aria-live="polite" aria-atomic="true">
          <h2 id="draftBannerMessage">We found an unpublished draft from a previous session.</h2>
          <div class="draft-actions">
            <button type="button" id="draftRestoreBtn" class="restore">Restore draft</button>
            <button type="button" id="draftDiscardBtn">Discard</button>
          </div>
          <div id="draftConfirm" class="draft-actions" hidden aria-live="polite" aria-atomic="true">
            <span>Discard this draft?</span>
            <button type="button" id="draftConfirmDiscard">Yes, discard</button>
            <button type="button" id="draftCancelDiscard">Keep</button>
          </div>
        </section>
        <input type="hidden" name="source_key" id="source_key" value="{{ active_source_key }}">
        <input type="hidden" name="mode" id="formMode" value="add">
        <input type="hidden" name="original_id" id="original_id" value="">
        <input type="hidden" name="source_hash" id="source_hash" value="">
        <section id="editNotice" class="edit-notice" hidden aria-live="polite" aria-atomic="true">
          <p id="editNoticeLabel"><strong>Editing:</strong> <span id="editNoticeValue"></span></p>
          <button type="button" id="exitEditModeBtn" class="secondary">Exit edit mode</button>
        </section>
        <h2 class="section-heading">Net details</h2>
        <fieldset>
          <legend>Net details</legend>

          <input type="hidden" id="id" name="id">
          <p class="hint" id="idDisplay" aria-live="off">ID will be generated from the net name.</p>

          <div class="field-header">
            <label for="name">Net name <span aria-hidden="true">*</span></label>
          </div>
          <div class="field-input">
            <input type="text" id="name" name="name" required>
            <button type="button" class="help-button" data-help="name" data-field-id="name" data-field-label="Net name" aria-expanded="false" aria-controls="help-name" aria-label="What does the Net name field mean?">?</button>
          </div>
          <p class="hint help-text" id="help-name"></p>

          <div class="field-header">
            <span id="categoryLegend">Category <span aria-hidden="true">*</span></span>
          </div>
          <div class="field-input">
            <div id="categoryOptions" role="radiogroup" aria-labelledby="categoryLegend">
              {% for cat in categories %}
              <label class="category-option">
                <input type="radio" name="categoryChoice" value="{{ cat }}" {% if loop.first %}checked{% endif %}>
                <span>{{ cat }}</span>
              </label>
              {% endfor %}
              <label class="category-option">
                <input type="radio" name="categoryChoice" value="__new__">
                <span>New category…</span>
              </label>
            </div>
            <button type="button" class="help-button" data-help="category" data-field-id="categoryOptions" data-field-label="Category" aria-expanded="false" aria-controls="help-category" aria-label="What does the Category field mean?">?</button>
          </div>
          <p class="hint help-text" id="help-category"></p>
          <input type="hidden" id="category" name="category" required>
          <div class="field-header" id="newCategoryHeader" hidden>
            <label for="newCategory" id="newCategoryLabel">New category name</label>
          </div>
          <div class="field-input" id="newCategoryInputGroup" hidden>
            <input type="text" id="newCategory" name="newCategory">
            <button type="button" class="help-button" data-help="newCategory" data-field-id="newCategory" data-field-label="New category name" aria-expanded="false" aria-controls="help-newCategory" aria-label="What does the New category field mean?">?</button>
          </div>
          <p class="hint help-text" id="help-newCategory" hidden></p>

          <div class="field-header">
            <label for="description">Description <span aria-hidden="true">*</span></label>
          </div>
          <div class="field-input">
            <textarea id="description" name="description" required></textarea>
            <button type="button" class="help-button" data-help="description" data-field-id="description" data-field-label="Description" aria-expanded="false" aria-controls="help-description" aria-label="What does the Description field mean?">?</button>
          </div>
          <p class="hint help-text" id="help-description"></p>

          <div class="field-header">
            <label for="start_local">Start time (net time) <span aria-hidden="true">*</span></label>
          </div>
          <div class="time-toggle">
            <button type="button" id="toggleTimeMode" aria-expanded="false" aria-controls="start_local_manual">Use 24-hour entry</button>
          </div>
          <div class="field-input" id="startTimeInputGroup">
            <input type="time" id="start_local" name="start_local" required aria-describedby="startTimeHint">
            <input type="text" id="start_local_manual" name="start_local_manual" placeholder="HH:MM" inputmode="numeric" pattern="^\\d{2}:\\d{2}$" hidden aria-hidden="true">
            <button type="button" class="help-button" data-help="start_local" data-field-id="start_local" data-field-label="Start time" aria-expanded="false" aria-controls="help-start_local" aria-label="What does the Start time field mean?">?</button>
          </div>
          <p class="hint" id="startTimeHint"></p>
          <p class="hint help-text" id="help-start_local"></p>

          <div class="field-header">
            <label for="time_zone">Time zone</label>
          </div>
          <div class="field-input">
            <select id="time_zone" name="time_zone" aria-describedby="tzHelp">
              <option value="">Use default ({{ default_time_zone }})</option>
              {% for tz in time_zones %}
              <option value="{{ tz }}">{{ tz }}</option>
              {% endfor %}
              <option value="__custom__">Custom…</option>
            </select>
            <button type="button" class="help-button" data-help="time_zone" data-field-id="time_zone" data-field-label="Time zone" aria-expanded="false" aria-controls="help-time_zone" aria-label="What does the Time zone field mean?">?</button>
          </div>
          <p class="hint help-text" id="help-time_zone"></p>
          <div id="tzHelp" class="hint">Provide only when the net is not in {{ default_time_zone }}.</div>
          <div class="field-header" id="customTimeZoneHeader" hidden>
            <label for="custom_time_zone" id="customTimeZoneLabel">Custom time zone (IANA)</label>
          </div>
          <div class="field-input" id="customTimeZoneInputGroup" hidden>
            <input type="hidden" id="custom_time_zone" name="custom_time_zone" data-visible-type="text" placeholder="e.g., Europe/London">
            <button type="button" class="help-button" data-help="custom_time_zone" data-field-id="custom_time_zone" data-field-label="Custom time zone" aria-expanded="false" aria-controls="help-custom_time_zone" aria-label="What does the Custom time zone field mean?" hidden disabled tabindex="-1">?</button>
          </div>
          <p class="hint help-text" id="help-custom_time_zone" hidden></p>

          <div class="field-header">
            <label for="duration_min">Duration (minutes) <span aria-hidden="true">*</span></label>
          </div>
          <div class="field-input">
            <input type="number" id="duration_min" name="duration_min" min="1" step="5" required>
            <button type="button" class="help-button" data-help="duration_min" data-field-id="duration_min" data-field-label="Duration" aria-expanded="false" aria-controls="help-duration_min" aria-label="What does the Duration field mean?">?</button>
          </div>
          <p class="hint help-text" id="help-duration_min"></p>

          <div class="field-header">
            <label for="rrule">RRULE <span aria-hidden="true">*</span></label>
          </div>
          <div class="field-input rrule-actions">
            <input type="text" id="rrule" name="rrule" placeholder="FREQ=WEEKLY;BYDAY=MO" required aria-describedby="rruleHint rruleDescription">
            <button type="button" class="help-button" data-help="rrule" data-field-id="rrule" data-field-label="RRULE" aria-expanded="false" aria-controls="help-rrule" aria-label="What does the RRULE field mean?">?</button>
            <button type="button" id="buildRruleBtn">Open RRULE builder</button>
          </div>
          <p class="hint help-text" id="help-rrule"></p>
          <p class="hint" id="rruleHint">Use the builder or paste a rule (RFC 5545). The description below updates automatically.</p>
          <p class="rrule-description" id="rruleDescription" aria-live="polite">No RRULE provided yet.</p>
          <details class="rrule-builder" id="rruleBuilder">
            <summary>RRULE builder (optional)</summary>
            <div class="rrule-builder-grid">
              <label for="builderFreq">Frequency
                <select id="builderFreq">
                  <option value="WEEKLY">Weekly</option>
                  <option value="DAILY">Daily</option>
                  <option value="MONTHLY">Monthly</option>
                </select>
              </label>
              <label for="builderInterval">Repeat every
                <input type="number" id="builderInterval" min="1" value="1">
                <span class="hint">Interval in frequency units</span>
              </label>
            </div>

            <div id="weeklyOptions" class="weekday-options" aria-live="polite">
              <label><input type="checkbox" value="MO">Monday</label>
              <label><input type="checkbox" value="TU">Tuesday</label>
              <label><input type="checkbox" value="WE">Wednesday</label>
              <label><input type="checkbox" value="TH">Thursday</label>
              <label><input type="checkbox" value="FR">Friday</label>
              <label><input type="checkbox" value="SA">Saturday</label>
              <label><input type="checkbox" value="SU">Sunday</label>
            </div>

            <div id="monthlyOptions" hidden>
              <label for="monthlyMode">Monthly pattern
                <select id="monthlyMode">
                  <option value="day">Specific day of month</option>
                  <option value="weekday">Nth weekday</option>
                </select>
              </label>
              <div id="monthlyDayContainer">
                <label for="monthlyDay">Day of month
                  <input type="number" id="monthlyDay" min="1" max="31" value="1">
                </label>
              </div>
              <div id="monthlyWeekdayContainer" hidden>
                <div id="monthlySetPosContainer">
                  <span class="hint">Which week(s) of the month?</span>
                  <div class="monthly-setpos-options" role="group" aria-label="Select week positions">
                    <label><input type="checkbox" value="1" class="monthly-setpos-option">First</label>
                    <label><input type="checkbox" value="2" class="monthly-setpos-option">Second</label>
                    <label><input type="checkbox" value="3" class="monthly-setpos-option">Third</label>
                    <label><input type="checkbox" value="4" class="monthly-setpos-option">Fourth</label>
                    <label><input type="checkbox" value="-1" class="monthly-setpos-option">Last</label>
                  </div>
                </div>
                <label for="monthlyWeekday">Weekday
                  <select id="monthlyWeekday">
                    <option value="MO">Monday</option>
                    <option value="TU">Tuesday</option>
                    <option value="WE">Wednesday</option>
                    <option value="TH">Thursday</option>
                    <option value="FR">Friday</option>
                    <option value="SA">Saturday</option>
                    <option value="SU">Sunday</option>
                  </select>
                </label>
              </div>
            </div>

            <div class="actions" style="margin-top: 0.75rem;">
              <button type="button" id="applyRrule">Apply to RRULE field</button>
            </div>
          </details>
        </fieldset>

        <h2 class="section-heading">Connections</h2>
        <fieldset>
          <legend>Connections</legend>
          <p class="hint">Select the connection types that apply to this net. Fields appear once you check a box.</p>
          <div class="connections-list">
            <label class="connection-toggle">
              <input type="checkbox" id="connAllStar" data-connection-label="AllStar">
              <span>AllStar</span>
            </label>
            <label class="connection-toggle">
              <input type="checkbox" id="connEchoLink" data-connection-label="EchoLink">
              <span>EchoLink</span>
            </label>
            <label class="connection-toggle">
              <input type="checkbox" id="connDMR" data-connection-label="DMR">
              <span>DMR</span>
            </label>
            <label class="connection-toggle">
              <input type="checkbox" id="connDStar" data-connection-label="DStar">
              <span>DStar</span>
            </label>
            <label class="connection-toggle">
              <input type="checkbox" id="connHF" data-connection-label="HF">
              <span>HF (frequency &amp; mode)</span>
            </label>
          </div>

          <div id="connection-allstar" class="connection-section" hidden aria-hidden="true" inert>
            <label for="allstar">AllStar node(s)</label>
            <input type="text" id="allstar" name="allstar" placeholder="e.g., 50631, 42726" disabled tabindex="-1">
          </div>

          <div id="connection-echolink" class="connection-section" hidden aria-hidden="true" inert>
            <label for="echolink">EchoLink node(s)</label>
            <input type="text" id="echolink" name="echolink" placeholder="e.g., *KV3T-L" disabled tabindex="-1">
          </div>

          <div id="connection-dmr" class="connection-section" hidden aria-hidden="true" inert>
            <p class="hint">Provide the DMR network and talkgroup used during the net.</p>
            <label for="dmr_system">DMR system</label>
            <input type="text" id="dmr_system" name="dmr_system" placeholder="e.g., BrandMeister" disabled tabindex="-1">
            <label for="dmr_tg">DMR talkgroup</label>
            <input type="text" id="dmr_tg" name="dmr_tg" placeholder="e.g., 31672" disabled tabindex="-1">
          </div>

          <div id="connection-dstar" class="connection-section" hidden aria-hidden="true" inert>
            <p class="hint">Provide the DStar reflector/module the net uses.</p>
            <label for="DStar">DStar connection</label>
            <input type="text" id="DStar" name="DStar" placeholder="e.g., XLX123A" disabled tabindex="-1">
          </div>

          <div id="connection-hf" class="connection-section" hidden aria-hidden="true" inert>
            <p class="hint">Record the HF frequency and mode used for this net.</p>
            <label for="frequency">Frequency</label>
            <input type="text" id="frequency" name="frequency" placeholder="e.g., 14.200" disabled tabindex="-1">
            <label for="mode">Mode</label>
            <select id="mode" name="mode" disabled tabindex="-1">
              <option value="">Select a mode</option>
              <option value="USB">Upper Sideband (USB)</option>
              <option value="LSB">Lower Sideband (LSB)</option>
              <option value="AM">AM</option>
              <option value="FM">FM</option>
              <option value="Digital">Digital</option>
              <option value="CW">CW</option>
              <option value="Other">Other</option>
            </select>
          </div>
        </fieldset>

        <details id="optionalFields">
          <summary><span class="section-heading">Optional extras</span></summary>
          <div class="optional-grid">
            {% for key in ["location", "peanut", "zoom", "notes"] %}
            <div>
              <label for="{{ key }}">{{ key | replace("_", " ") | title }}</label>
              <div class="field-input">
                <input type="text" id="{{ key }}" name="{{ key }}">
                <button type="button" class="help-button" data-help="{{ key|lower }}" data-field-id="{{ key }}" data-field-label="{{ key | replace('_', ' ') | title }}" aria-expanded="false" aria-controls="help-{{ key|lower|replace('_', '-') }}" aria-label="What does the {{ key | replace('_', ' ') | title }} field mean?">?</button>
              </div>
              <p class="hint help-text" id="help-{{ key|lower|replace('_', '-') }}"></p>
            </div>
            {% endfor %}
          </div>

          <div class="custom-field-block">
            <h3>Custom fields</h3>
            <p class="hint">Need a field that is not listed above? Add it here.</p>
            <div id="customFields"></div>
            <button type="button" id="addCustomField">Add custom field</button>
          </div>
        </details>

        <div class="actions">
          <button type="button" id="addToBatchBtn" class="primary">Add to batch</button>
          <button type="button" id="previewBtn" class="primary">Preview JSON</button>
          <button type="button" id="saveBtn">Save draft for review</button>
        </div>
        <div class="submission-note">
          <label for="submission_note">Submission note (optional)</label>
          <textarea id="submission_note" name="submission_note" aria-describedby="submissionNoteHint"></textarea>
          <p class="hint" id="submissionNoteHint">This note appears to publishers when reviewing the draft (for example &ldquo;Rachel &ndash; added AllStar node details&rdquo;).</p>
        </div>
        <p class="hint" id="saveDraftHint" hidden>Saving a draft is disabled while reviewing a submitted batch. Use “Add to batch” and “Submit batch” to update this draft.</p>
        <p id="autosaveStatus" class="autosave-status" hidden aria-live="polite"></p>
      </form>

      <section id="batchControls" class="batch-controls" hidden aria-labelledby="batchHeading">
        <h2 id="batchHeading">Batch queue</h2>
        <p id="batchSummary" class="batch-summary">No staged nets yet. Add nets to the batch to see them listed here.</p>
        <ul id="batchList" class="batch-list" aria-live="polite"></ul>
        <div class="actions">
          <button type="button" id="submitBatchBtn" class="primary" disabled>Submit batch for publication</button>
          <button type="button" id="clearBatchBtn" class="secondary" disabled>Clear batch</button>
        </div>
      </section>

      <div aria-live="polite" id="liveStatus" class="status" hidden></div>

      <section aria-live="polite" aria-atomic="true">
        <h2>Preview</h2>
        <pre id="jsonPreview">Preview will appear here after you press “Preview JSON”.</pre>
      </section>
    </main>

    <template id="customFieldTemplate">
      <div class="custom-field">
        <label>Key
          <input type="text" data-field="key" placeholder="e.g., hubnet_channel">
        </label>
        <label>Value
          <input type="text" data-field="value" placeholder="Text to store">
        </label>
        <button type="button" data-action="remove">Remove</button>
      </div>
    </template>

    <div id="batchModal" class="modal-backdrop" hidden>
      <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="batchModalTitle">
        <h2 id="batchModalTitle">Submit batch for publication</h2>
        <p id="batchModalCount">You are about to submit 0 staged nets.</p>
        <label for="batchNoteInput">Note to publishers (optional)</label>
        <textarea id="batchNoteInput" placeholder="e.g., Added updated contact info for two nets."></textarea>
        <div class="modal-actions">
          <button type="button" id="batchModalConfirm" class="primary">Submit batch</button>
          <button type="button" id="batchModalCancel" class="secondary">Cancel</button>
        </div>
      </div>
    </div>

    <script>
      const pendingContext = {{ pending_context|tojson }};
      const form = document.getElementById('netsForm');
      const previewBtn = document.getElementById('previewBtn');
      const saveBtn = document.getElementById('saveBtn');
      const statusBox = document.getElementById('liveStatus');
      const jsonPreview = document.getElementById('jsonPreview');
      const sourceInput = document.getElementById('source_key');
      const sourcePicker = document.getElementById('sourcePicker');
      const deleteSelectedBtn = document.getElementById('deleteSelected');
      const deleteAllBtn = document.getElementById('deleteAllPending');
      const currentSnapshot = document.getElementById('currentSnapshot');
      const pendingStatusHint = document.getElementById('pendingStatusHint');
      const categoryField = document.getElementById('category');
      const categoryRadios = Array.from(document.querySelectorAll('input[name="categoryChoice"]'));
      const categoryOptionsContainer = document.getElementById('categoryOptions');
      const newCategoryInput = document.getElementById('newCategory');
      const newCategoryLabel = document.getElementById('newCategoryLabel');
      const newCategoryHeader = document.getElementById('newCategoryHeader');
      const newCategoryInputGroup = document.getElementById('newCategoryInputGroup');
      const timeZoneSelect = document.getElementById('time_zone');
      const customTimeZoneInput = document.getElementById('custom_time_zone');
      const customTimeZoneVisibleType = customTimeZoneInput ? (customTimeZoneInput.dataset.visibleType || 'text') : 'text';
      const customTimeZoneLabel = document.getElementById('customTimeZoneLabel');
      const customTimeZoneHeader = document.getElementById('customTimeZoneHeader');
      const customTimeZoneInputGroup = document.getElementById('customTimeZoneInputGroup');
      const customFieldsContainer = document.getElementById('customFields');
      const customFieldTemplate = document.getElementById('customFieldTemplate');
      const addCustomFieldButton = document.getElementById('addCustomField');
      const helpButtons = Array.from(document.querySelectorAll('.help-button'));
      const helpButtonMap = {};
      const helpTargets = {};
      const helpLabels = new Map();
      const srAnnounce = document.getElementById('srAnnounce');
      const newCategoryHelpButton = document.querySelector('[data-help="newCategory"]');
      const customTimeZoneHelpButton = document.querySelector('[data-help="custom_time_zone"]');
      const customTimeZoneHelpText = document.getElementById('help-custom_time_zone');
      const helpTexts = {{ help_texts|tojson }};
      const predefinedLabels = {{ help_labels|tojson }};
      const draftBanner = document.getElementById('draftBanner');
      const draftBannerMessage = document.getElementById('draftBannerMessage');
      const draftRestoreBtn = document.getElementById('draftRestoreBtn');
      const draftDiscardBtn = document.getElementById('draftDiscardBtn');
      const draftConfirm = document.getElementById('draftConfirm');
      const draftConfirmDiscard = document.getElementById('draftConfirmDiscard');
      const draftCancelDiscard = document.getElementById('draftCancelDiscard');
      const autosaveStatus = document.getElementById('autosaveStatus');
      const modeInput = document.getElementById('formMode');
      const originalIdInput = document.getElementById('original_id');
      const editNotice = document.getElementById('editNotice');
      const editNoticeValue = document.getElementById('editNoticeValue');
      const exitEditModeBtn = document.getElementById('exitEditModeBtn');
      const netList = document.getElementById('netList');
      const netListStatus = document.getElementById('netListStatus');
      const netLoadSelectedBtn = document.getElementById('netLoadSelectedBtn');
      const netSearchInput = document.getElementById('netSearch');
      const netSearchLoadBtn = document.getElementById('netSearchLoadBtn');
      const editControlsSection = document.getElementById('editControls');
      const pendingReviewSection = document.getElementById('pendingReview');
      const pendingToggleBtn = document.getElementById('pendingToggleBtn');
      const pendingReviewHint = document.getElementById('pendingReviewHint');
      const pendingListContainer = document.getElementById('pendingList');
      const batchControls = document.getElementById('batchControls');
      const batchSummary = document.getElementById('batchSummary');
      const batchList = document.getElementById('batchList');
      const addToBatchBtn = document.getElementById('addToBatchBtn');
      const submitBatchBtn = document.getElementById('submitBatchBtn');
      const clearBatchBtn = document.getElementById('clearBatchBtn');
      const batchModal = document.getElementById('batchModal');
      const batchModalCount = document.getElementById('batchModalCount');
      const batchModalNote = document.getElementById('batchNoteInput');
      const batchModalConfirm = document.getElementById('batchModalConfirm');
      const batchModalCancel = document.getElementById('batchModalCancel');
      const idField = document.getElementById('id');
      const idDisplay = document.getElementById('idDisplay');
      const saveDraftHint = document.getElementById('saveDraftHint');
      const submissionNoteContainer = document.querySelector('.submission-note');
      const initialExistingIds = {{ existing_ids|tojson }};
      const initialExistingIdsLower = new Set(initialExistingIds.map((id) => String(id || '').toLowerCase()));
      const connectionConfigs = [
        {
          key: 'allstar',
          label: 'AllStar',
          checkbox: document.getElementById('connAllStar'),
          section: document.getElementById('connection-allstar'),
          fields: ['allstar'],
        },
        {
          key: 'echolink',
          label: 'EchoLink',
          checkbox: document.getElementById('connEchoLink'),
          section: document.getElementById('connection-echolink'),
          fields: ['echolink'],
        },
        {
          key: 'dmr',
          label: 'DMR',
          checkbox: document.getElementById('connDMR'),
          section: document.getElementById('connection-dmr'),
          fields: ['dmr_system', 'dmr_tg'],
        },
        {
          key: 'dstar',
          label: 'DStar',
          checkbox: document.getElementById('connDStar'),
          section: document.getElementById('connection-dstar'),
          fields: ['DStar'],
        },
        {
          key: 'hf',
          label: 'HF',
          checkbox: document.getElementById('connHF'),
          section: document.getElementById('connection-hf'),
          fields: ['frequency', 'mode'],
        },
      ];
      const AUTO_SAVE_KEY_ACTIVE = 'bhn:nets-helper:draft:active';
      const AUTO_SAVE_KEY_PENDING = 'bhn:nets-helper:draft:pending';
      const canPromote = Boolean(pendingContext && pendingContext.permissions && pendingContext.permissions.can_promote);
      const canReview = Boolean(pendingContext && pendingContext.permissions && pendingContext.permissions.can_review);
      const BATCH_STORAGE_KEY = 'bhn:nets-helper:batch:queue:v1';
      let batchQueue = [];
      let batchModalReturnFocus = null;
      let batchSubmissionInFlight = false;
      const AUTO_SAVE_DEBOUNCE_MS = 3000;
      const AUTO_SAVE_ANNOUNCE_MS = 60000;
      let autoSaveTimer = null;
      let lastAutoSaveAnnounce = 0;
      let applyingDraft = false;
      let draftBannerVisible = false;
      let activeDraftPayload = null;
      let netIndex = [];
      let filteredNetIndex = [];
      let pendingReviewVisible = false;
      const editingState = {
        active: false,
        originalId: '',
        label: '',
      };

      function pendingCountLabel(count) {
        if (!count) {
          return 'none waiting';
        }
        if (count === 1) {
          return '1 waiting';
        }
        return `${count} waiting`;
      }

      function updatePendingReviewToggle(count) {
        if (!pendingToggleBtn) {
          return;
        }
        const label = count ? `Review drafts (${pendingCountLabel(count)})` : 'Review drafts (none waiting)';
        pendingToggleBtn.textContent = label;
        pendingToggleBtn.setAttribute('aria-expanded', pendingReviewVisible ? 'true' : 'false');
      }

      function setPendingReviewVisibility(show) {
        pendingReviewVisible = !!show;
        if (pendingReviewSection) {
          pendingReviewSection.hidden = !pendingReviewVisible;
        }
        if (pendingToggleBtn) {
          pendingToggleBtn.setAttribute('aria-expanded', pendingReviewVisible ? 'true' : 'false');
        }
      }

      function updateSaveDraftState(sourceKey) {
        if (!saveBtn) {
          return;
        }
        const isPendingSource = typeof sourceKey === 'string' && sourceKey.startsWith('pending:');
        if (!canPromote) {
          saveBtn.hidden = true;
          saveBtn.disabled = true;
          if (saveDraftHint) {
            saveDraftHint.hidden = true;
          }
          return;
        }
        if (isPendingSource) {
          saveBtn.hidden = true;
          saveBtn.disabled = true;
          if (saveDraftHint) {
            saveDraftHint.hidden = false;
          }
        } else {
          saveBtn.hidden = false;
          saveBtn.disabled = false;
          if (saveDraftHint) {
            saveDraftHint.hidden = true;
          }
        }
      }

      function buildBatchKey(payload) {
        const mode = (payload.mode || 'add').toLowerCase();
        if (mode === 'edit' && payload.original_id) {
          return `edit|${String(payload.original_id).toLowerCase()}`;
        }
        return `add|${String(payload.id || '').toLowerCase()}`;
      }

      function buildBatchLabel(payload) {
        const id = payload.id || '(no id)';
        const name = payload.name ? ` — ${payload.name}` : '';
        return `${id}${name}`;
      }

      function markBatchErrors(errorMap) {
        batchQueue.forEach((item) => {
          item.errors = null;
        });
        if (!errorMap || typeof errorMap !== 'object') {
          return;
        }
        Object.entries(errorMap).forEach(([index, errors]) => {
          const idx = Number.parseInt(index, 10);
          if (Number.isNaN(idx) || idx < 0 || idx >= batchQueue.length) {
            return;
          }
          batchQueue[idx].errors = errors;
        });
      }

      function renderBatchQueue() {
        if (!batchControls) {
          return;
        }
        if (!canReview) {
          batchControls.hidden = true;
          return;
        }
        batchControls.hidden = false;
        const hasItems = batchQueue.length > 0;
        if (batchSummary) {
          batchSummary.textContent = hasItems
            ? `Batch contains ${batchQueue.length} staged net${batchQueue.length === 1 ? '' : 's'}.`
            : 'No staged nets yet. Add nets to the batch to see them listed here.';
        }
        if (submitBatchBtn) {
          submitBatchBtn.disabled = !hasItems || batchSubmissionInFlight;
        }
        if (clearBatchBtn) {
          clearBatchBtn.disabled = !hasItems || batchSubmissionInFlight;
        }
        if (!batchList) {
          return;
        }
        batchList.innerHTML = '';
        if (!hasItems) {
          const empty = document.createElement('li');
          empty.className = 'batch-item';
          empty.textContent = 'No staged nets yet.';
          batchList.appendChild(empty);
          return;
        }
        batchQueue.forEach((item, index) => {
          const li = document.createElement('li');
          li.className = 'batch-item';
          const header = document.createElement('div');
          header.className = 'batch-item-header';
          const title = document.createElement('span');
          title.textContent = `${index + 1}. ${item.label}`;
          const modeBadge = document.createElement('span');
          modeBadge.className = 'batch-item-mode';
          if (item.mode === 'edit') {
            modeBadge.textContent = 'Mode: Edit';
            modeBadge.setAttribute('aria-label', 'Batch item mode: edit');
          } else {
            modeBadge.textContent = 'Mode: Add';
            modeBadge.setAttribute('aria-label', 'Batch item mode: add');
          }
          header.append(title, modeBadge);
          li.appendChild(header);
          const metaParts = [];
          if (item.payload && item.payload.category) {
            metaParts.push(String(item.payload.category));
          }
          if (item.payload && item.payload.start_local) {
            metaParts.push(`starts ${item.payload.start_local}`);
          }
          if (item.payload && item.payload.time_zone) {
            metaParts.push(item.payload.time_zone);
          }
          if (metaParts.length) {
            const meta = document.createElement('div');
            meta.className = 'batch-item-meta';
            meta.textContent = metaParts.join(' • ');
            li.appendChild(meta);
          }
          const actions = document.createElement('div');
          actions.className = 'batch-item-actions';
          const loadBtn = document.createElement('button');
          loadBtn.type = 'button';
          loadBtn.className = 'secondary';
          loadBtn.dataset.action = 'load';
          loadBtn.dataset.index = String(index);
          loadBtn.textContent = 'Load into form';
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'secondary';
          removeBtn.dataset.action = 'remove';
          removeBtn.dataset.index = String(index);
          removeBtn.textContent = 'Remove';
          actions.append(loadBtn, removeBtn);
          li.appendChild(actions);
          if (item.errors) {
            const errorBlock = document.createElement('div');
            errorBlock.className = 'batch-item-error';
            const messages = Object.values(item.errors);
            errorBlock.textContent = messages.join(' ');
            li.appendChild(errorBlock);
          }
          batchList.appendChild(li);
        });
      }

      function saveBatchToStorage() {
        if (typeof localStorage === 'undefined') {
          return;
        }
        try {
          if (!batchQueue.length) {
            localStorage.removeItem(BATCH_STORAGE_KEY);
            return;
          }
          const data = {
            version: 1,
            items: batchQueue.map((item) => ({
              payload: item.payload,
              formState: item.formState,
              label: item.label,
              mode: item.mode,
              key: item.key,
            })),
          };
          localStorage.setItem(BATCH_STORAGE_KEY, JSON.stringify(data));
        } catch (error) {
          console.warn('Unable to save batch queue', error);
        }
      }

      function clearBatchStorage() {
        if (typeof localStorage === 'undefined') {
          return;
        }
        try {
          localStorage.removeItem(BATCH_STORAGE_KEY);
        } catch (error) {
          console.warn('Unable to clear stored batch queue', error);
        }
      }

      function loadBatchFromStorage() {
        if (typeof localStorage === 'undefined') {
          return;
        }
        let data = null;
        try {
          const raw = localStorage.getItem(BATCH_STORAGE_KEY);
          if (!raw) {
            return;
          }
          data = JSON.parse(raw);
        } catch (error) {
          console.warn('Unable to load stored batch queue', error);
          return;
        }
        if (!data || !Array.isArray(data.items)) {
          return;
        }
        batchQueue = data.items.map((item) => {
          const payload = item && typeof item.payload === 'object' ? item.payload : {};
          return {
            payload,
            formState: item && typeof item.formState === 'object' ? item.formState : null,
            label: item && item.label ? item.label : buildBatchLabel(payload),
            mode: (item && item.mode) ? String(item.mode).toLowerCase() : 'add',
            key: item && item.key ? item.key : buildBatchKey(payload),
            errors: null,
          };
        });
      }

      function addPayloadToBatch(entry) {
        const existingIndex = batchQueue.findIndex((item) => item.key === entry.key);
        if (existingIndex >= 0) {
          batchQueue.splice(existingIndex, 1, entry);
          return { index: existingIndex, updated: true };
        }
        batchQueue.push(entry);
        return { index: batchQueue.length - 1, updated: false };
      }

      async function handleAddToBatch() {
        if (!canReview) {
          showStatus('You do not have permission to stage drafts.', 'error');
          return;
        }
        clearStatus();
        const payload = collectFormData();
        const formState = collectDraftPayload();
        try {
          const response = await fetch(buildApiUrl('api/preview'), requestOptions(payload));
          const body = await parseResponse(response);
          if (!response.ok) {
            renderErrors(body.errors || {});
            return;
          }
          const entry = {
            key: buildBatchKey(payload),
            payload,
            formState: JSON.parse(JSON.stringify(formState || {})),
            label: buildBatchLabel(payload),
            mode: (payload.mode || 'add').toLowerCase(),
            errors: null,
          };
          const result = addPayloadToBatch(entry);
          markBatchErrors(null);
          saveBatchToStorage();
          renderBatchQueue();
          resetFormAfterSave();
          if (body.snippet) {
            jsonPreview.textContent = body.snippet;
          }
          const message = result.updated
            ? `${entry.label} updated in the batch.`
            : `${entry.label} added to batch.`;
          showStatus(message, 'success');
        } catch (error) {
          renderErrors({ general: error.message });
        }
      }

      function loadBatchItem(index) {
        if (!canReview || index < 0 || index >= batchQueue.length) {
          return;
        }
        const item = batchQueue[index];
        batchQueue.splice(index, 1);
        markBatchErrors(null);
        saveBatchToStorage();
        renderBatchQueue();
        const formState = item.formState || {
          values: item.payload || {},
          meta: {
            editing: {
              isEditing: item.mode === 'edit',
              originalId: item.payload && item.payload.original_id ? item.payload.original_id : '',
              label: item.label,
            },
          },
        };
        applyFormState(formState, { announceMessage: 'Staged net restored for editing.' });
        showStatus('Loaded staged net into the form. Update the details and add it back to the batch when ready.', 'success');
      }

      function removeBatchItem(index) {
        if (!canReview || index < 0 || index >= batchQueue.length) {
          return;
        }
        batchQueue.splice(index, 1);
        markBatchErrors(null);
        if (batchQueue.length) {
          saveBatchToStorage();
        } else {
          clearBatchStorage();
        }
        renderBatchQueue();
        showStatus('Staged net removed from batch.', 'success');
      }

      function clearBatch() {
        if (!canReview || !batchQueue.length) {
          return;
        }
        if (!window.confirm('Remove all staged nets from this batch?')) {
          return;
        }
        batchQueue = [];
        markBatchErrors(null);
        clearBatchStorage();
        renderBatchQueue();
        showStatus('Batch cleared.', 'success');
      }

      function openBatchModal() {
        if (!canReview || !batchQueue.length || !batchModal) {
          return;
        }
        batchModalReturnFocus = document.activeElement;
        batchModal.hidden = false;
        const count = batchQueue.length;
        if (batchModalCount) {
          batchModalCount.textContent = `You are about to submit ${count} staged net${count === 1 ? '' : 's'}.`;
        }
        if (batchModalNote) {
          batchModalNote.value = '';
          setTimeout(() => {
            try {
              batchModalNote.focus({ preventScroll: true });
            } catch (_err) {}
          }, 0);
        }
      }

      function closeBatchModal({ focusRestore = true } = {}) {
        if (!batchModal) {
          return;
        }
        batchModal.hidden = true;
        if (batchModalConfirm) {
          batchModalConfirm.disabled = false;
        }
        if (focusRestore && batchModalReturnFocus && typeof batchModalReturnFocus.focus === 'function') {
          try {
            batchModalReturnFocus.focus({ preventScroll: true });
          } catch (_err) {}
        }
        batchModalReturnFocus = null;
      }

      async function submitBatchRequest() {
        if (!canReview || !batchQueue.length || batchSubmissionInFlight) {
          closeBatchModal();
          return;
        }
        batchSubmissionInFlight = true;
        if (batchModalConfirm) {
          batchModalConfirm.disabled = true;
        }
        if (submitBatchBtn) {
          submitBatchBtn.disabled = true;
        }
        clearStatus();
        const payload = {
          nets: batchQueue.map((item) => item.payload),
        };
        const note = batchModalNote ? batchModalNote.value.trim() : '';
        if (note) {
          payload.note = note;
        }
        try {
          const response = await fetch(buildApiUrl('api/batch/submit'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const body = await parseResponse(response);
          if (!response.ok) {
            if (body && body.errors) {
              markBatchErrors(body.errors);
              renderBatchQueue();
              showStatus('Please fix the highlighted nets before submitting.', 'error');
            } else {
              showStatus(body && body.error ? body.error : 'Unable to submit batch.', 'error');
            }
            return;
          }
          batchQueue = [];
          clearBatchStorage();
          renderBatchQueue();
          closeBatchModal();
          showStatus(body.message || 'Batch submitted.', 'success');
          if (body.active_source) {
            updateActiveSource(body.active_source);
          } else {
            updateActiveSource('nets');
          }
          await loadPendingOverview();
          setPendingReviewVisibility(false);
        } catch (error) {
          showStatus(error.message || 'Unable to submit batch.', 'error');
        } finally {
          batchSubmissionInFlight = false;
          if (batchModalConfirm) {
            batchModalConfirm.disabled = false;
          }
          if (submitBatchBtn) {
            submitBatchBtn.disabled = batchQueue.length === 0;
          }
        }
      }

      function initializeBatchUI() {
        if (!canPromote && saveBtn) {
          saveBtn.hidden = true;
          saveBtn.disabled = true;
        }
        if (!canPromote && submissionNoteContainer) {
          submissionNoteContainer.hidden = true;
        }
        if (!canReview) {
          if (batchControls) {
            batchControls.hidden = true;
          }
          if (addToBatchBtn) {
            addToBatchBtn.hidden = true;
            addToBatchBtn.disabled = true;
          }
          if (submitBatchBtn) {
            submitBatchBtn.hidden = true;
          }
          if (clearBatchBtn) {
            clearBatchBtn.hidden = true;
          }
          return;
        }
        loadBatchFromStorage();
        renderBatchQueue();
      }

      setPendingReviewVisibility(false);
      updatePendingReviewToggle((pendingContext && Array.isArray(pendingContext.pending) && pendingContext.pending.length) ? pendingContext.pending.length : 0);
      initializeBatchUI();
      updateSaveDraftState((pendingContext && pendingContext.active_source) || 'nets');

      function buildApiUrl(path) {
        const trimmed = String(path || '').replace(/^\//, '');
        return new URL(trimmed, window.location.href).toString();
      }

      function netOptionLabel(item) {
        const id = item.id || '';
        const name = item.name ? ` — ${item.name}` : '';
        const category = item.category ? ` (${item.category})` : '';
        return `${id}${name}${category}`.trim();
      }

      function updateNetListStatus(count, customMessage) {
        if (!netListStatus) {
          return;
        }
        if (customMessage) {
          netListStatus.textContent = customMessage;
          return;
        }
        if (!count) {
          netListStatus.textContent = 'No nets found.';
        } else {
          netListStatus.textContent = count === 1 ? '1 net available.' : `${count} nets available.`;
        }
      }

      function syncLoadSelectedButton() {
        if (!netLoadSelectedBtn || !netList) {
          return;
        }
        netLoadSelectedBtn.disabled = netList.disabled || !netList.value;
      }

      syncLoadSelectedButton();

      function escapeSelector(value) {
        if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
          return CSS.escape(value);
        }
        return String(value).replace(/[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g, '\\$&');
      }

      function sanitizeLabel(text) {
        if (!text) return '';
        let cleaned = text.replace(/\s+/g, ' ').trim();
        cleaned = cleaned.replace(/^What does the\s+/i, '');
        cleaned = cleaned.replace(/\s+field(?:s)? mean\??$/i, '');
        cleaned = cleaned.replace(/\s+\?$/, '');
        cleaned = cleaned.replace(/\s*\*+$/, '');
        return cleaned.trim();
      }

      function deriveHelpLabel(button, fieldId) {
        let labelText = button.dataset.fieldLabel || '';
        if (!labelText) {
          const key = button.dataset.help;
          if (key && predefinedLabels && Object.prototype.hasOwnProperty.call(predefinedLabels, key)) {
            labelText = predefinedLabels[key] || '';
          }
        }
        if (!labelText && fieldId) {
          if (fieldId === 'categoryOptions') {
            const legend = document.getElementById('categoryLegend');
            if (legend) {
              labelText = legend.textContent || '';
            }
          } else {
            const labelEl = document.querySelector(`label[for="${escapeSelector(fieldId)}"]`);
            if (labelEl) {
              labelText = labelEl.textContent || '';
            }
            if (!labelText) {
              const legendEl = document.getElementById(`${fieldId}Legend`);
              if (legendEl) {
                labelText = legendEl.textContent || '';
              }
            }
          }
        }
        if (!labelText) {
          labelText = button.getAttribute('aria-label') || '';
        }
        return sanitizeLabel(labelText);
      }

      function speak(message) {
        if (!srAnnounce || !message) return;
        srAnnounce.textContent = '';
        srAnnounce.textContent = message;
      }

      function announceHelp(targetId, isOpen, target) {
        const labelText = helpLabels.get(targetId) || 'Field';
        if (isOpen) {
          const helpText = target ? sanitizeLabel(target.textContent || '') : '';
          if (helpText) {
            speak(`${labelText} help expanded. ${helpText}`);
          } else {
            speak(`${labelText} help expanded.`);
          }
        } else {
          speak(`${labelText} help collapsed.`);
        }
      }

      if (sourcePicker) {
        updateSourceSelectionUI();
        sourcePicker.addEventListener('change', handleSourceChange);
      }
      if (deleteSelectedBtn) {
        deleteSelectedBtn.addEventListener('click', handleDeleteSelected);
      }
      if (deleteAllBtn) {
        deleteAllBtn.addEventListener('click', handleDeleteAll);
      }
      const rruleInput = document.getElementById('rrule');
      const rruleDescription = document.getElementById('rruleDescription');
      const buildRruleBtn = document.getElementById('buildRruleBtn');
      const rruleBuilderDetails = document.getElementById('rruleBuilder');
      const builderFreq = document.getElementById('builderFreq');
      const builderInterval = document.getElementById('builderInterval');
      const weeklyOptions = document.getElementById('weeklyOptions');
      const monthlyOptions = document.getElementById('monthlyOptions');
      const monthlyMode = document.getElementById('monthlyMode');
      const monthlyDayContainer = document.getElementById('monthlyDayContainer');
      const monthlyWeekdayContainer = document.getElementById('monthlyWeekdayContainer');
      const monthlyDay = document.getElementById('monthlyDay');
      const monthlySetPosContainer = document.getElementById('monthlySetPosContainer');
      const monthlySetPosOptions = Array.from(document.querySelectorAll('.monthly-setpos-option'));
      const monthlyWeekday = document.getElementById('monthlyWeekday');
      const applyRruleButton = document.getElementById('applyRrule');
      const netNameInput = document.getElementById('name');
      const startTimePicker = document.getElementById('start_local');
      const startTimeManual = document.getElementById('start_local_manual');
      const toggleTimeModeBtn = document.getElementById('toggleTimeMode');
      const startTimeInputGroup = document.getElementById('startTimeInputGroup');
      const startTimeHint = document.getElementById('startTimeHint');
      let manualTimeMode = false;
      const errorFields = new Set();

      function findField(name) {
        switch (name) {
          case 'category':
            return categoryOptionsContainer;
          case 'newCategory':
            return newCategoryInput;
          case 'custom_time_zone':
            return customTimeZoneInput;
          case 'start_local':
            return manualTimeMode ? startTimeManual : startTimePicker;
          case 'conflict':
            return form.elements.id;
          default:
            return form.elements[name] || document.getElementById(name) || null;
        }
      }

      function markFieldError(name) {
        const field = findField(name);
        if (!field) {
          return null;
        }
        errorFields.add(field);
        field.setAttribute('aria-invalid', 'true');
        if (field.classList) {
          field.classList.add('field-error');
        }
        const wrapper = field.closest ? field.closest('.field-input') : null;
        if (wrapper) {
          wrapper.classList.add('field-error');
        }
        const current = field.getAttribute('aria-describedby') || '';
        if (!current.includes('liveStatus')) {
          field.dataset.prevDescribedby = current;
          const next = `${current} liveStatus`.trim();
          field.setAttribute('aria-describedby', next);
        }
        if (field === categoryOptionsContainer) {
          return categoryRadios[0] || null;
        }
        return field;
      }

      function clearFieldError(field) {
        if (!field || !errorFields.has(field)) {
          return;
        }
        field.removeAttribute('aria-invalid');
        if (field.classList) {
          field.classList.remove('field-error');
        }
        if (Object.prototype.hasOwnProperty.call(field.dataset, 'prevDescribedby')) {
          const previous = field.dataset.prevDescribedby;
          if (previous) {
            field.setAttribute('aria-describedby', previous);
          } else {
            field.removeAttribute('aria-describedby');
          }
          delete field.dataset.prevDescribedby;
        }
        errorFields.delete(field);
        const wrapper = field.closest ? field.closest('.field-input') : null;
        if (wrapper) {
          wrapper.classList.remove('field-error');
        }
      }

      function clearFieldErrors() {
        Array.from(errorFields).forEach((field) => clearFieldError(field));
      }

      categoryRadios.forEach((radio) => {
        radio.addEventListener('change', () => {
          handleCategoryChange(radio.value);
        });
      });
      const preselectedCategory = categoryRadios.find((radio) => radio.checked);
      if (preselectedCategory) {
        handleCategoryChange(preselectedCategory.value);
      } else {
        handleCategoryChange(categoryField.value || '');
      }

      function toggleFieldGroup(group, input, show, extras = []) {
        const APPLY_STYLE = (el, visible) => {
          if (!el) return;
          if (visible) {
            el.removeAttribute('hidden');
            el.removeAttribute('aria-hidden');
            el.style.display = '';
            el.removeAttribute('inert');
            if ('disabled' in el) {
              el.disabled = false;
            }
            el.removeAttribute('tabindex');
          } else {
            el.setAttribute('hidden', '');
            el.setAttribute('aria-hidden', 'true');
            el.style.display = 'none';
            el.setAttribute('inert', '');
            if ('disabled' in el) {
              el.disabled = true;
            }
            el.setAttribute('tabindex', '-1');
          }
        };

        APPLY_STYLE(group, show);
        APPLY_STYLE(input, show);
        extras.forEach((element) => APPLY_STYLE(element, show));
      }

      function slugify(value) {
        return String(value || '')
          .normalize('NFKD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^A-Za-z0-9\s_-]/g, '')
          .trim()
          .replace(/[\s_-]+/g, '-')
          .replace(/^-+|-+$/g, '')
          .toLowerCase();
      }

      function isIdTaken(candidate) {
        const lower = String(candidate || '').toLowerCase();
        if (!lower) {
          return false;
        }
        if (initialExistingIdsLower.has(lower)) {
          return true;
        }
        if (netIndex.some((item) => String(item.id || '').toLowerCase() === lower)) {
          return true;
        }
        if (pendingContext && Array.isArray(pendingContext.pending)) {
          for (const entry of pendingContext.pending) {
            if (!entry || !Array.isArray(entry.changes)) {
              continue;
            }
            if (entry.changes.some((change) => String(change.id || '').toLowerCase() === lower)) {
              return true;
            }
          }
        }
        return false;
      }

      function generateUniqueId(base) {
        const cleanBase = base || 'net';
        let candidate = cleanBase;
        let counter = 2;
        while (isIdTaken(candidate)) {
          candidate = `${cleanBase}-${counter}`;
          counter += 1;
        }
        return candidate;
      }

      function updateIdDisplay(idValue) {
        if (!idDisplay) {
          return;
        }
        if (idValue) {
          idDisplay.innerHTML = `Generated ID: <code>${escapeHtml(idValue)}</code>`;
        } else {
          idDisplay.textContent = 'ID will be generated from the net name.';
        }
      }

      function autoAssignId({ force = false } = {}) {
        if (!idField) {
          return;
        }
        if (editingState.active) {
          if (force && idField.value) {
            updateIdDisplay(idField.value);
          } else if (!idField.value) {
            updateIdDisplay('');
          }
          return;
        }
        const name = netNameInput ? netNameInput.value.trim() : '';
        if (!name) {
          idField.value = '';
          if (force) {
            updateIdDisplay('');
          }
          return;
        }
        const base = slugify(name) || 'net';
        const unique = generateUniqueId(base);
        idField.value = unique;
        if (force) {
          updateIdDisplay(unique);
        }
      }

      function resolveConnectionFields(config) {
        config.fieldElements = config.fields
          .map((name) => form.elements[name])
          .filter(Boolean);
        return config.fieldElements;
      }

      function connectionHasData(config) {
        const fields = resolveConnectionFields(config);
        return fields.some((el) => {
          if (!el) return false;
          if (el.tagName === 'SELECT') {
            return Boolean(el.value);
          }
          return Boolean(String(el.value || '').trim());
        });
      }

      function clearConnectionFields(config) {
        const fields = resolveConnectionFields(config);
        fields.forEach((el) => {
          if (!el) return;
          if (el.tagName === 'SELECT') {
            el.selectedIndex = 0;
          } else {
            el.value = '';
          }
        });
      }

      function setConnectionSectionVisibility(config, visible, { focusFirst = false } = {}) {
        const section = config.section;
        if (!section) return;
        section.hidden = !visible;
        section.setAttribute('aria-hidden', visible ? 'false' : 'true');
        if (visible) {
          section.removeAttribute('inert');
          section.style.display = '';
        } else {
          section.setAttribute('inert', '');
          section.style.display = 'none';
        }
        const focusTargets = [];
        section.querySelectorAll('input, select, textarea, button').forEach((el) => {
          if (!el || el === config.checkbox) return;
          if (visible) {
            if (el.dataset.visibleType) {
              el.type = el.dataset.visibleType;
            }
            el.disabled = false;
            el.removeAttribute('tabindex');
            focusTargets.push(el);
          } else {
            if (el.dataset.visibleType) {
              el.type = 'hidden';
            }
            el.disabled = true;
            el.setAttribute('tabindex', '-1');
          }
        });
        if (visible && focusFirst) {
          const first = focusTargets.find((el) => el.tagName !== 'BUTTON');
          if (first) {
            setTimeout(() => {
              if (typeof first.focus === 'function') {
                first.focus({ preventScroll: true });
              }
            }, 0);
            announce(`${config.label} connection fields ready.`);
          }
        }
      }

      function setConnectionState(config, enable, { announceChanges = true, allowPrompt = true, initialize = false } = {}) {
        const hasData = connectionHasData(config);
        if (enable) {
          setConnectionSectionVisibility(config, true, { focusFirst: !initialize });
          config.checkbox.setAttribute('aria-expanded', 'true');
          if (!initialize && announceChanges) {
            announce(`${config.label} connection expanded.`);
          }
          if (!initialize) {
            queueAutosave();
          }
          return;
        }

        if (!initialize && allowPrompt && hasData) {
          const confirmDrop = window.confirm(`Remove ${config.label} connection details?`);
          if (!confirmDrop) {
            config.checkbox.checked = true;
            if (announceChanges) {
              announce(`${config.label} connection kept.`);
            }
            return;
          }
          clearConnectionFields(config);
        }

        setConnectionSectionVisibility(config, false);
        config.checkbox.setAttribute('aria-expanded', 'false');
        if (!initialize && announceChanges) {
          announce(`${config.label} connection collapsed.`);
        }
        if (!initialize) {
          queueAutosave();
        }
      }

      function cancelAutosave() {
        if (autoSaveTimer) {
          clearTimeout(autoSaveTimer);
          autoSaveTimer = null;
        }
      }

      function queueAutosave() {
        if (applyingDraft) {
          return;
        }
        if (typeof localStorage === 'undefined') {
          return;
        }
        cancelAutosave();
        autoSaveTimer = setTimeout(() => {
          autoSaveTimer = null;
          saveDraftToStorage();
        }, AUTO_SAVE_DEBOUNCE_MS);
      }

      function clearDraft() {
        cancelAutosave();
        try {
          if (typeof localStorage !== 'undefined') {
            localStorage.removeItem(AUTO_SAVE_KEY_ACTIVE);
            localStorage.removeItem(AUTO_SAVE_KEY_PENDING);
          }
        } catch (_err) {}
        lastAutoSaveAnnounce = 0;
        draftBannerVisible = false;
        activeDraftPayload = null;
        hideDraftBanner();
        updateAutosaveStatus(null);
      }

      function collectDraftPayload() {
        const payload = {
          version: 1,
          timestamp: Date.now(),
          values: {},
          customFields: [],
          connections: [],
        meta: {
          manualTimeMode,
          startPicker: startTimePicker.value,
          startManual: startTimeManual.value,
          categoryChoice: '',
          sourceKey: sourceInput ? sourceInput.value : '',
          editing: {
            isEditing: editingState.active,
            originalId: editingState.originalId,
            label: editingState.label,
          },
        },
      };

        const formData = new FormData(form);
        formData.forEach((value, name) => {
          if (name === 'categoryChoice' || name === 'start_local_manual') {
            return;
          }
          payload.values[name] = value;
        });

        if (modeInput && !payload.values.mode) {
          payload.values.mode = modeInput.value;
        }
        if (originalIdInput && !payload.values.original_id) {
          payload.values.original_id = originalIdInput.value;
        }

        const selectedCategory = categoryRadios.find((radio) => radio.checked);
        if (selectedCategory) {
          payload.meta.categoryChoice = selectedCategory.value;
          payload.values.category = selectedCategory.value;
        }

        payload.customFields = Array.from(customFieldsContainer.querySelectorAll('.custom-field')).map((block) => {
          const keyInput = block.querySelector('[data-field="key"]');
          const valueInput = block.querySelector('[data-field="value"]');
          return {
            key: keyInput ? keyInput.value : '',
            value: valueInput ? valueInput.value : '',
          };
        });

        payload.connections = connectionConfigs.map((config) => ({
          key: config.key,
          enabled: !!(config.checkbox && config.checkbox.checked),
        }));

        return payload;
      }

      function saveDraftToStorage() {
        if (applyingDraft) {
          return;
        }
        if (typeof localStorage === 'undefined') {
          return;
        }
        try {
          const payload = collectDraftPayload();
          const key = draftBannerVisible ? AUTO_SAVE_KEY_PENDING : AUTO_SAVE_KEY_ACTIVE;
          localStorage.setItem(key, JSON.stringify(payload));
          if (!draftBannerVisible) {
            localStorage.removeItem(AUTO_SAVE_KEY_PENDING);
          }
          updateAutosaveStatus(payload.timestamp);
          const now = Date.now();
          if (now - lastAutoSaveAnnounce > AUTO_SAVE_ANNOUNCE_MS) {
            announce('Draft saved automatically.');
            lastAutoSaveAnnounce = now;
          }
        } catch (error) {
          console.warn('Unable to save draft', error);
        }
      }

      function updateAutosaveStatus(timestamp) {
        if (!autosaveStatus) {
          return;
        }
        if (!timestamp) {
          autosaveStatus.hidden = true;
          autosaveStatus.textContent = '';
          return;
        }
        const savedAt = new Date(timestamp);
        const formatter = new Intl.DateTimeFormat(undefined, {
          hour: 'numeric',
          minute: '2-digit',
        });
        autosaveStatus.hidden = false;
        autosaveStatus.textContent = `Draft saved at ${formatter.format(savedAt)}.`;
      }

      function showDraftBanner(payload) {
        if (!draftBanner) {
          applyFormState(payload, { announceMessage: 'Draft restored.', fromDraft: true });
          return;
        }
        draftBannerVisible = true;
        activeDraftPayload = payload;
        const savedAt = new Date(payload.timestamp || Date.now());
        const formatter = new Intl.DateTimeFormat(undefined, {
          dateStyle: 'medium',
          timeStyle: 'short',
        });
        if (draftBannerMessage) {
          draftBannerMessage.textContent = `We found an unpublished draft from ${formatter.format(savedAt)}.`;
        }
        draftBanner.hidden = false;
        draftBanner.setAttribute('aria-hidden', 'false');
        if (draftConfirm) {
          draftConfirm.hidden = true;
          draftConfirm.setAttribute('aria-hidden', 'true');
        }
      }

      function hideDraftBanner() {
        if (!draftBanner) {
          return;
        }
        draftBanner.hidden = true;
        draftBanner.setAttribute('aria-hidden', 'true');
        draftBannerVisible = false;
        activeDraftPayload = null;
        if (draftConfirm) {
          draftConfirm.hidden = true;
          draftConfirm.setAttribute('aria-hidden', 'true');
        }
      }

      function loadDraftFromStorage() {
        if (typeof localStorage === 'undefined') {
          return;
        }
        let rawActive = null;
        try {
          rawActive = localStorage.getItem(AUTO_SAVE_KEY_ACTIVE);
        } catch (error) {
          console.warn('Unable to read active draft', error);
          return;
        }
        if (!rawActive) {
          try {
            localStorage.removeItem(AUTO_SAVE_KEY_PENDING);
          } catch (_err) {}
          return;
        }
        let draft = null;
        try {
          draft = JSON.parse(rawActive);
        } catch (error) {
          console.warn('Unable to parse draft', error);
          clearDraft();
          return;
        }
        if (!draft || typeof draft !== 'object') {
          clearDraft();
          return;
        }
        showDraftBanner(draft);
      }

      function isRadioGroup(field) {
        return field && typeof field.length === 'number' && typeof field.item === 'function' && !field.tagName;
      }

      function applyFormState(state, { announceMessage = 'Draft restored.', fromDraft = false } = {}) {
        applyingDraft = true;
        cancelAutosave();
        try {
          const values = state && typeof state === 'object' && state.values ? state.values : {};
          const meta = state && typeof state === 'object' && state.meta ? state.meta : {};
          const customFieldData = state && Array.isArray(state.customFields) ? state.customFields : [];
          const connectionData = state && Array.isArray(state.connections) ? state.connections : [];

          customFieldsContainer.innerHTML = '';
          customFieldData.forEach(({ key, value }) => {
            const fragment = customFieldTemplate.content.cloneNode(true);
            const keyInput = fragment.querySelector('[data-field="key"]');
            const valueInput = fragment.querySelector('[data-field="value"]');
            if (keyInput) keyInput.value = key || '';
            if (valueInput) valueInput.value = value || '';
            customFieldsContainer.appendChild(fragment);
          });

          const connectionState = new Map(connectionData.map((entry) => [entry.key, entry.enabled]));
          connectionConfigs.forEach((config) => {
            if (!config.checkbox) return;
            const enabled = connectionState.has(config.key)
              ? Boolean(connectionState.get(config.key))
              : connectionHasData(config);
            config.checkbox.checked = enabled;
            setConnectionState(config, enabled, {
              announceChanges: false,
              allowPrompt: false,
              initialize: true,
            });
          });

          const connectionFieldNames = new Set(connectionConfigs.flatMap((cfg) => cfg.fields));

          Object.entries(values).forEach(([name, value]) => {
            if (connectionFieldNames.has(name)) {
              return;
            }
            if (name === 'category') {
              categoryField.value = value;
              const radio = categoryRadios.find((r) => r.value === value);
              if (radio) {
                radio.checked = true;
              }
              handleCategoryChange(value);
              return;
            }
            if (name === 'time_zone') {
              timeZoneSelect.value = value || '';
              applyTimeZoneSelection(value || '', { focusCustom: false });
              return;
            }
            if (name === 'start_local') {
              startTimePicker.value = value || '';
              return;
            }
            const field = form.elements[name];
            if (!field) {
              return;
            }
            if (isRadioGroup(field)) {
              Array.from(field).forEach((node) => {
                node.checked = node.value === value;
              });
            } else if (field.type === 'checkbox') {
              field.checked = value === 'on' || value === true || value === 'true';
            } else {
              field.value = value;
            }
          });

          connectionConfigs.forEach((config) => {
            const fields = resolveConnectionFields(config);
            fields.forEach((field) => {
              if (!field) return;
              const storedValue = values[field.name];
              if (storedValue !== undefined) {
                field.value = storedValue;
              }
            });
          });

          if (meta.categoryChoice) {
            const radio = categoryRadios.find((r) => r.value === meta.categoryChoice);
            if (radio) {
              radio.checked = true;
              categoryField.value = meta.categoryChoice;
              handleCategoryChange(meta.categoryChoice);
            }
          }

          manualTimeMode = Boolean(meta.manualTimeMode);
          startTimePicker.value = meta.startPicker || startTimePicker.value;
          startTimeManual.value = meta.startManual || '';
          updateTimeMode();
          updateRruleDescription();

          if (meta.sourceKey && sourceInput) {
            sourceInput.value = meta.sourceKey;
          }

          const editingMeta = meta.editing || {};
          const originalIdValue = values.original_id || editingMeta.originalId || '';
          if (modeInput) {
            const modeValue = values.mode || (editingMeta.isEditing ? 'edit' : modeInput.defaultValue || 'add');
            modeInput.value = modeValue || 'add';
          }
          if (originalIdInput) {
            originalIdInput.value = originalIdValue;
          }
          const shouldEdit = (modeInput && modeInput.value === 'edit' && originalIdValue) || editingMeta.isEditing;
          if (shouldEdit) {
            const label = editingMeta.label || originalIdValue || '';
            enterEditMode(originalIdValue, label, { silent: true });
          } else {
            exitEditMode({ silent: true });
          }

          if (idField) {
            const newIdValue = values.id || originalIdValue || idField.value || '';
            idField.value = newIdValue;
            updateIdDisplay(newIdValue);
          } else {
            updateIdDisplay(values.id || originalIdValue || '');
          }

          const timestamp = state && typeof state.timestamp === 'number' ? state.timestamp : Date.now();
          updateAutosaveStatus(timestamp);
          if (announceMessage) {
            announce(announceMessage);
          }
          if (shouldEdit && !fromDraft) {
            focusNameField();
          }
        } catch (error) {
          console.warn('Unable to apply form state', error);
        } finally {
          applyingDraft = false;
          lastAutoSaveAnnounce = Date.now();
          queueAutosave();
        }
      }

      function handleCategoryChange(value) {
        categoryField.value = value || '';
        const useCustom = value === '__new__';
        toggleFieldGroup(newCategoryInputGroup, newCategoryInput, useCustom, [newCategoryHelpButton]);
        newCategoryInput.required = useCustom;
        newCategoryLabel.hidden = !useCustom;
        newCategoryHeader.hidden = !useCustom;
        setHelpVisibility('help-newCategory', false, { silent: true });
        if (useCustom) {
          newCategoryInput.focus();
        } else {
          newCategoryInput.value = '';
        }
        clearFieldError(newCategoryInput);
        clearFieldError(categoryOptionsContainer);
      }

      function applyTimeZoneSelection(value, { focusCustom = false } = {}) {
        const custom = value === '__custom__';
        const extras = [customTimeZoneHelpButton, customTimeZoneHelpText, customTimeZoneHeader, customTimeZoneLabel].filter(Boolean);
        toggleFieldGroup(customTimeZoneInputGroup, customTimeZoneInput, custom, extras);
        customTimeZoneInput.required = custom;
        customTimeZoneInput.type = custom ? customTimeZoneVisibleType : 'hidden';
        customTimeZoneLabel.hidden = !custom;
        customTimeZoneHeader.hidden = !custom;
        setHelpVisibility('help-custom_time_zone', false, { silent: true });
        if (custom) {
          if (focusCustom) {
            customTimeZoneInput.focus();
          }
        } else {
          customTimeZoneInput.value = '';
          customTimeZoneInput.blur();
        }
        clearFieldError(customTimeZoneInput);
        clearFieldError(timeZoneSelect);
      }

      timeZoneSelect.addEventListener('change', () => {
        applyTimeZoneSelection(timeZoneSelect.value, { focusCustom: timeZoneSelect.value === '__custom__' });
      });

      connectionConfigs.forEach((config) => {
        if (!config.checkbox || !config.section) {
          return;
        }
        resolveConnectionFields(config);
        config.checkbox.setAttribute('aria-controls', config.section.id);
        const initialEnabled = config.checkbox.checked || connectionHasData(config);
        config.checkbox.checked = initialEnabled;
        setConnectionState(config, initialEnabled, {
          announceChanges: false,
          allowPrompt: false,
          initialize: true,
        });
        config.checkbox.addEventListener('change', () => {
          setConnectionState(config, config.checkbox.checked, {
            announceChanges: true,
            allowPrompt: true,
            initialize: false,
          });
        });
      });

      addCustomFieldButton.addEventListener('click', () => {
        const fragment = customFieldTemplate.content.cloneNode(true);
        customFieldsContainer.appendChild(fragment);
        queueAutosave();
      });

      function enterEditMode(originalId, label = '', { silent = false } = {}) {
        const normalizedId = String(originalId || '').trim();
        if (!normalizedId) {
          return;
        }
        editingState.active = true;
        editingState.originalId = normalizedId;
        editingState.label = label || normalizedId;
        if (modeInput) {
          modeInput.value = 'edit';
        }
        if (originalIdInput) {
          originalIdInput.value = normalizedId;
        }
        if (editNotice) {
          editNotice.hidden = false;
          editNotice.setAttribute('aria-hidden', 'false');
        }
        if (editNoticeValue) {
          editNoticeValue.textContent = editingState.label;
        }
        if (exitEditModeBtn) {
          exitEditModeBtn.hidden = false;
          exitEditModeBtn.disabled = false;
        }
        updateNetSelectionUI();
        if (!silent) {
          announce(`${editingState.label} ready for editing. Adjust the fields and save to queue changes.`);
        }
      }

      function exitEditMode({ silent = false } = {}) {
        editingState.active = false;
        editingState.originalId = '';
        editingState.label = '';
        if (modeInput) {
          modeInput.value = modeInput.defaultValue || 'add';
        }
        if (originalIdInput) {
          originalIdInput.value = '';
        }
        const sourceHashInput = document.getElementById('source_hash');
        if (sourceHashInput) {
          sourceHashInput.value = '';
        }
        if (editNotice) {
          editNotice.hidden = true;
          editNotice.setAttribute('aria-hidden', 'true');
        }
        if (editNoticeValue) {
          editNoticeValue.textContent = '';
        }
        updateNetSelectionUI();
        if (!silent) {
          announce('Edit mode cleared. Ready to add a new net.');
        }
      }

      function updateNetSelectionUI() {
        if (!netList) {
          return;
        }
        if (!editingState.active || !editingState.originalId) {
          if (netList.selectedIndex === -1 && netList.options.length) {
            netList.selectedIndex = 0;
          }
          syncLoadSelectedButton();
          return;
        }
        const target = editingState.originalId.toLowerCase();
        let matched = false;
        Array.from(netList.options).forEach((option) => {
          if (option.value.toLowerCase() === target) {
            option.selected = true;
            matched = true;
          }
        });
        if (!matched) {
          netList.selectedIndex = -1;
        }
        syncLoadSelectedButton();
      }

      function focusNetSelector() {
        if (netList && !netList.disabled) {
          netList.focus({ preventScroll: true });
          return;
        }
        if (netSearchInput && !netSearchInput.disabled) {
          netSearchInput.focus({ preventScroll: true });
          return;
        }
        if (sourcePicker) {
          sourcePicker.focus({ preventScroll: true });
        }
      }

      customFieldsContainer.addEventListener('click', (event) => {
        const button = event.target.closest('[data-action="remove"]');
        if (!button) return;
        const block = button.closest('.custom-field');
        if (block) {
          block.remove();
          queueAutosave();
        }
      });

      toggleTimeModeBtn.addEventListener('click', () => {
        manualTimeMode = !manualTimeMode;
        clearFieldError(startTimePicker);
        clearFieldError(startTimeManual);
        updateTimeMode({ focus: true });
        updateRruleDescription();
      });

      startTimePicker.addEventListener('input', () => {
        updateRruleDescription();
      });
      startTimeManual.addEventListener('input', () => {
        updateRruleDescription();
      });
      startTimeManual.addEventListener('blur', () => {
        const normalized = normalizeTime(startTimeManual.value);
        if (normalized) {
          startTimeManual.value = normalized;
        }
      });

      buildRruleBtn.addEventListener('click', () => {
        rruleBuilderDetails.open = true;
        builderFreq.focus();
        rruleBuilderDetails.scrollIntoView({ behavior: 'smooth', block: 'center' });
      });

      builderFreq.addEventListener('change', () => {
        updateBuilderVisibility();
      });

      monthlyMode.addEventListener('change', () => {
        const useWeekday = monthlyMode.value === 'weekday';
        monthlyDayContainer.hidden = useWeekday;
        monthlyWeekdayContainer.hidden = !useWeekday;
      });

      applyRruleButton.addEventListener('click', () => {
        const freq = builderFreq.value;
        const parts = [`FREQ=${freq}`];
        const interval = Math.max(parseInt(builderInterval.value, 10) || 1, 1);
        if (interval > 1) {
          parts.push(`INTERVAL=${interval}`);
        }

        if (freq === 'WEEKLY') {
          const selected = Array.from(weeklyOptions.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
          if (!selected.length) {
            showStatus('Select at least one weekday for a weekly pattern.', 'error');
            weeklyOptions.querySelector('input')?.focus();
            return;
          }
          parts.push(`BYDAY=${selected.join(',')}`);
        } else if (freq === 'MONTHLY') {
          if (monthlyMode.value === 'day') {
            const day = Math.min(Math.max(parseInt(monthlyDay.value, 10) || 1, 1), 31);
            parts.push(`BYMONTHDAY=${day}`);
          } else {
            const selectedPositions = monthlySetPosOptions
              .filter((cb) => cb.checked)
              .map((cb) => parseInt(cb.value, 10))
              .filter((value) => !Number.isNaN(value));
            if (!selectedPositions.length) {
              showStatus('Select at least one week position for the monthly pattern.', 'error');
              monthlySetPosContainer?.querySelector('input')?.focus();
              return;
            }
            const deduped = Array.from(new Set(selectedPositions)).sort((a, b) => {
              if (a === b) return 0;
              if (a === -1) return 1;
              if (b === -1) return -1;
              return a - b;
            });
            parts.push(`BYDAY=${monthlyWeekday.value}`);
            parts.push(`BYSETPOS=${deduped.join(',')}`);
          }
        }

        rruleInput.value = parts.join(';');
        updateRruleDescription();
        announce('RRULE updated from builder.');
        try {
          rruleBuilderDetails.open = false;
          builderFreq.focus({ preventScroll: true });
        } catch (_err) {}
      });

      rruleInput.addEventListener('input', () => {
        updateRruleDescription();
      });

      if (netNameInput) {
        netNameInput.addEventListener('input', () => {
          autoAssignId();
        });
        netNameInput.addEventListener('blur', () => {
          updateRruleDescription();
        });
      }

      function setHelpVisibility(targetId, show, options = {}) {
        const { silent = false } = options;
        const target = helpTargets[targetId] || document.getElementById(targetId);
        if (!target) return;
        helpTargets[targetId] = target;
        target.dataset.show = show ? 'true' : 'false';
        target.hidden = !show;
        const button = helpButtonMap[targetId];
        if (button) {
          button.setAttribute('aria-expanded', show ? 'true' : 'false');
        }
        const alreadyInitialized = target.dataset.helpInit === 'true';
        target.dataset.helpInit = 'true';
        if (!silent && alreadyInitialized) {
          announceHelp(targetId, show, target);
        }
      }

      helpButtons.forEach((button) => {
        const key = button.dataset.help;
        const targetId = button.getAttribute('aria-controls');
        const target = document.getElementById(targetId);
        if (target) {
          if (helpTexts && Object.prototype.hasOwnProperty.call(helpTexts, key) && helpTexts[key]) {
            target.textContent = helpTexts[key];
          }
        }
        if (target) {
          helpTargets[targetId] = target;
          helpButtonMap[targetId] = button;
          const fieldId = button.dataset.fieldId || '';
          const labelText = deriveHelpLabel(button, fieldId);
          if (labelText) {
            button.dataset.fieldLabel = labelText;
            helpLabels.set(targetId, labelText);
          }
          const initialShow = target.dataset.show === 'true';
          setHelpVisibility(targetId, initialShow, { silent: true });
        } else {
          button.setAttribute('aria-disabled', 'true');
        }
        button.addEventListener('click', () => {
          if (!target) return;
          const show = target.dataset.show !== 'true';
          setHelpVisibility(targetId, show);
          if (show && typeof target.focus === 'function') {
            target.focus({ preventScroll: true });
          }
        });
      });

      updateAutosaveStatus(null);
      updateBuilderVisibility();
      updateTimeMode();
      monthlyMode.dispatchEvent(new Event('change'));
      updateRruleDescription();
      applyTimeZoneSelection(timeZoneSelect.value || '');
      loadDraftFromStorage();
      updatePendingStatusHint();
      const initialSourceKey = (sourceInput && sourceInput.value) || (pendingContext && pendingContext.active_source) || 'nets';
      loadNetIndex(initialSourceKey);
      loadPendingOverview();
      autoAssignId({ force: true });

      window.addEventListener('beforeunload', () => {
        saveDraftToStorage();
      });

      if (draftRestoreBtn) {
        draftRestoreBtn.addEventListener('click', () => {
          if (!activeDraftPayload) {
            hideDraftBanner();
            return;
          }
          const payload = activeDraftPayload;
          hideDraftBanner();
          try {
            localStorage.removeItem(AUTO_SAVE_KEY_PENDING);
          } catch (_err) {}
          applyFormState(payload, { announceMessage: 'Draft restored.', fromDraft: true });
        });
      }

      if (draftDiscardBtn) {
        draftDiscardBtn.addEventListener('click', () => {
          if (!draftConfirm) {
            clearDraft();
            announce('Saved draft discarded.');
            return;
          }
          draftConfirm.hidden = false;
          draftConfirm.setAttribute('aria-hidden', 'false');
          draftConfirmDiscard?.focus({ preventScroll: true });
        });
      }

      if (draftConfirmDiscard) {
        draftConfirmDiscard.addEventListener('click', () => {
          clearDraft();
          announce('Saved draft discarded.');
        });
      }

      if (draftCancelDiscard) {
        draftCancelDiscard.addEventListener('click', () => {
          if (draftConfirm) {
            draftConfirm.hidden = true;
            draftConfirm.setAttribute('aria-hidden', 'true');
          }
          announce('Draft kept.');
        });
      }

      previewBtn.addEventListener('click', async () => {
        clearStatus();
        const payload = collectFormData();
        try {
          const response = await fetch(buildApiUrl('api/preview'), requestOptions(payload));
          const body = await parseResponse(response);
          if (!response.ok) {
            renderErrors(body.errors || {});
            return;
          }
          jsonPreview.textContent = body.snippet;
          announce('Preview ready.');
        } catch (error) {
          renderErrors({ general: error.message });
        }
      });

      form.addEventListener('input', (event) => {
        clearFieldError(event.target);
        queueAutosave();
      });

      form.addEventListener('change', (event) => {
        if (event.target.name === 'categoryChoice') {
          clearFieldError(categoryOptionsContainer);
        } else {
          clearFieldError(event.target);
        }
        queueAutosave();
      });

      if (netSearchInput) {
        netSearchInput.addEventListener('input', () => applyNetSearch());
        netSearchInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleNetSearchLoad();
          }
        });
      }

      if (netSearchLoadBtn) {
        netSearchLoadBtn.addEventListener('click', () => {
          handleNetSearchLoad();
        });
      }

      if (netList) {
        netList.addEventListener('change', () => {
          syncLoadSelectedButton();
        });
        netList.addEventListener('dblclick', () => {
          if (netList.value) {
            loadNetForEdit(netList.value);
          }
        });
        netList.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && !event.altKey && !event.ctrlKey && !event.metaKey) {
            event.preventDefault();
            if (netList.value) {
              loadNetForEdit(netList.value);
            }
          }
        });
      }

      if (netLoadSelectedBtn) {
        netLoadSelectedBtn.addEventListener('click', () => {
          if (netList && netList.value) {
            loadNetForEdit(netList.value);
          } else {
            announce('Select a net from the list first.');
            if (netList && !netList.disabled) {
              netList.focus({ preventScroll: true });
            }
          }
        });
      }

      const showManagersBtn = document.getElementById('showManagersBtn');
      const managerInfo = document.getElementById('managerInfo');
      const roleNames = (pendingContext && pendingContext.role_names) || {};
      function renderManagerInfo() {
        if (!managerInfo) return;
        const lines = [];
        const publishers = Array.isArray(roleNames.publishers) ? roleNames.publishers : [];
        const reviewers = Array.isArray(roleNames.reviewers) ? roleNames.reviewers : [];
        if (publishers.length) {
          lines.push(`<p><strong>Publishers (can promote to live):</strong> ${publishers.join(', ')}</p>`);
        }
        if (reviewers.length) {
          lines.push(`<p><strong>Reviewers:</strong> ${reviewers.join(', ')}</p>`);
        }
        if (!lines.length) {
          lines.push('<p>No team members listed.</p>');
        }
        managerInfo.innerHTML = lines.join('\n');
      }
      if (showManagersBtn && managerInfo) {
        renderManagerInfo();
        showManagersBtn.addEventListener('click', () => {
          const isHidden = managerInfo.hasAttribute('hidden');
          if (isHidden) {
            managerInfo.removeAttribute('hidden');
            managerInfo.setAttribute('aria-hidden', 'false');
            showManagersBtn.setAttribute('aria-expanded', 'true');
            renderManagerInfo();
          } else {
            managerInfo.setAttribute('hidden', '');
            managerInfo.setAttribute('aria-hidden', 'true');
            showManagersBtn.setAttribute('aria-expanded', 'false');
          }
        });
      }

      if (pendingListContainer) {
        pendingListContainer.addEventListener('click', (event) => {
          const loadBtn = event.target.closest('button[data-load-id]');
          if (loadBtn && loadBtn.dataset.loadId) {
            loadNetForEdit(loadBtn.dataset.loadId);
            return;
          }
          const promoteBtn = event.target.closest('button[data-action="promote"]');
          if (promoteBtn && promoteBtn.dataset.key) {
            promotePending(promoteBtn.dataset.key);
          }
        });
      }

      if (addToBatchBtn) {
        addToBatchBtn.addEventListener('click', () => {
          handleAddToBatch();
        });
      }

      if (submitBatchBtn) {
        submitBatchBtn.addEventListener('click', () => {
          if (!canReview) {
            showStatus('You do not have permission to submit batches.', 'error');
            return;
          }
          if (!batchQueue.length) {
            showStatus('No staged nets to submit yet.', 'error');
            return;
          }
          openBatchModal();
        });
      }

      if (clearBatchBtn) {
        clearBatchBtn.addEventListener('click', () => {
          clearBatch();
        });
      }

      if (batchList) {
        batchList.addEventListener('click', (event) => {
          const button = event.target.closest('button[data-action]');
          if (!button) {
            return;
          }
          const index = Number.parseInt(button.dataset.index || '-1', 10);
          const action = button.dataset.action;
          if (action === 'load') {
            loadBatchItem(index);
          } else if (action === 'remove') {
            removeBatchItem(index);
          }
        });
      }

      if (batchModalCancel) {
        batchModalCancel.addEventListener('click', () => {
          if (!batchSubmissionInFlight) {
            closeBatchModal();
          }
        });
      }

      if (batchModalConfirm) {
        batchModalConfirm.addEventListener('click', () => {
          submitBatchRequest();
        });
      }

      if (batchModal) {
        batchModal.addEventListener('click', (event) => {
          if (event.target === batchModal && !batchSubmissionInFlight) {
            closeBatchModal();
          }
        });
        batchModal.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && !batchSubmissionInFlight) {
            event.preventDefault();
            closeBatchModal();
          }
        });
      }

      if (pendingToggleBtn) {
        pendingToggleBtn.addEventListener('click', () => {
          const shouldShow = !pendingReviewVisible;
          setPendingReviewVisibility(shouldShow);
          if (shouldShow) {
            loadPendingOverview();
          }
        });
      }

      if (exitEditModeBtn) {
        exitEditModeBtn.addEventListener('click', () => {
          if (editingState.active) {
            const confirmExit = window.confirm('Exit edit mode and clear the form? Unsaved changes will be discarded.');
            if (!confirmExit) {
              return;
            }
          }
          exitEditMode({ silent: false });
          clearDraft();
          prepareFormForNewNet({ announceMessage: null, focus: false });
          focusNetSelector();
        });
      }

      saveBtn.addEventListener('click', async () => {
        clearStatus();
        const payload = collectFormData();
        try {
          const response = await fetch(buildApiUrl('api/save'), requestOptions(payload));
          const body = await parseResponse(response);
          if (!response.ok) {
            renderErrors(body.errors || {});
            return;
          }
          jsonPreview.textContent = body.snippet;
          showStatus(body.message || 'Draft saved for review.', 'success');
          const nextSource = body.active_source || (pendingContext && pendingContext.active_source) || 'nets';
          updateActiveSource(nextSource);
          await loadPendingOverview();
          resetFormAfterSave();
        } catch (error) {
          renderErrors({ general: error.message });
        }
      });

      function collectFormData() {
        const formData = new FormData(form);
        const payload = Object.fromEntries(formData.entries());

        payload.custom_fields = Array.from(customFieldsContainer.querySelectorAll('.custom-field')).map(block => {
          return {
            key: block.querySelector('[data-field="key"]').value,
            value: block.querySelector('[data-field="value"]').value,
          };
        });

        payload.connections = connectionConfigs.map((config) => ({
          key: config.key,
          enabled: !!(config.checkbox && config.checkbox.checked),
        }));

        payload.start_local = getCurrentStartTime();
        if (sourceInput) {
          payload.source_key = sourceInput.value || (pendingContext && pendingContext.active_source) || 'nets';
        } else if (pendingContext && pendingContext.active_source) {
          payload.source_key = pendingContext.active_source;
        }
        const originalIdValue = (payload.original_id || editingState.originalId || '').trim();
        payload.original_id = originalIdValue;
        let modeValue = (payload.mode || (editingState.active ? 'edit' : 'add')).toLowerCase();
        modeValue = modeValue === 'edit' ? 'edit' : 'add';
        if (modeValue === 'edit' && !originalIdValue) {
          modeValue = 'add';
        }
        payload.mode = modeValue;
        delete payload.categoryChoice;
        delete payload.start_local_manual;

        if (idField && (!payload.id || !String(payload.id).trim())) {
          autoAssignId({ force: true });
          payload.id = idField.value;
        }

        return payload;
      }

      function requestOptions(payload) {
        return {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        };
      }

      async function parseResponse(response) {
        const text = await response.text();
        try {
          return JSON.parse(text);
        } catch (_err) {
          throw new Error('Server returned an unexpected response.');
        }
      }

      function updateActiveSource(sourceKey) {
        if (!sourceKey) return;
        if (sourceInput) {
          sourceInput.value = sourceKey;
          sourceInput.defaultValue = sourceKey;
        }
        if (sourcePicker) {
          const option = Array.from(sourcePicker.options).find((opt) => opt.value === sourceKey);
          if (option) {
            sourcePicker.value = sourceKey;
            updateSourceSelectionUI();
          }
        }
        if (pendingContext) {
          pendingContext.active_source = sourceKey;
        }
        updateSaveDraftState(sourceKey);
        exitEditMode({ silent: true });
        loadNetIndex(sourceKey);
      }

      function handleSourceChange() {
        const option = selectedSourceOption();
        if (!option) {
          return;
        }
        const value = option.value;
        sourceInput.value = value;
        if (pendingContext) {
          pendingContext.active_source = value;
        }
        updateSaveDraftState(value);
        updateSourceSelectionUI();
        const url = new URL(window.location.href);
        url.searchParams.set('source', value);
        window.history.replaceState({}, '', url);
        exitEditMode({ silent: true });
        loadNetIndex(value);
      }

      function handleDeleteSelected() {
        const option = selectedSourceOption();
        if (!option || option.dataset.isPending !== 'true') {
          showStatus('Select a draft before deleting.', 'error');
          return;
        }
        const label = option.dataset.name || option.textContent.trim() || option.value;
        if (!window.confirm(`Delete draft “${label}”? This cannot be undone.`)) {
          return;
        }
        deletePending('single', option.value, 'nets');
      }

      function handleDeleteAll() {
        if (!pendingContext || !pendingContext.has_pending) {
          return;
        }
        if (!window.confirm('Delete all drafts? This cannot be undone.')) {
          return;
        }
        deletePending('all', null, 'nets');
      }

      async function deletePending(mode, key, nextSource) {
        clearStatus();
        const payload = { mode };
        if (mode === 'single' && key) {
          payload.key = key;
        }
        try {
          const response = await fetch(buildApiUrl('api/pending'), {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const body = await parseResponse(response);
          if (!response.ok) {
            showStatus(body.error || 'Unable to delete draft.', 'error');
            return;
          }
          const removedCount = Array.isArray(body.deleted) ? body.deleted.length : 0;
          let removalMessage;
          if (removedCount > 1) {
            removalMessage = `${removedCount} drafts removed.`;
          } else if (removedCount === 1) {
            removalMessage = 'Draft removed.';
          } else {
            removalMessage = mode === 'single' ? 'Draft removed.' : 'Drafts removed.';
          }
          announce(removalMessage);
          const next = nextSource || 'nets';
          updateActiveSource(next);
          await loadPendingOverview();
        } catch (error) {
          showStatus(error.message, 'error');
        }
      }

      function updateSourceSelectionUI() {
        const option = selectedSourceOption();
        if (!option) {
          return;
        }
        const isPending = option.dataset.isPending === 'true';
        if (deleteSelectedBtn) {
          deleteSelectedBtn.disabled = !isPending;
        }
        if (currentSnapshot) {
          const label = option.dataset.name || option.textContent.trim() || option.value;
          let snapshotHtml = `Currently editing: <code>${escapeHtml(label)}</code>`;
          const submittedBy = option.dataset.submittedBy || '';
          const submittedAt = option.dataset.submittedAt || '';
          const note = option.dataset.note || '';
          const detailParts = [];
          if (submittedBy) {
            detailParts.push(`submitted by ${escapeHtml(submittedBy)}`);
          }
          if (submittedAt) {
            const submittedDate = new Date(submittedAt);
            const formatted = Number.isNaN(submittedDate.valueOf()) ? submittedAt : submittedDate.toLocaleString();
            detailParts.push(`saved ${escapeHtml(formatted)}`);
          }
          if (detailParts.length) {
            snapshotHtml += `<br><span class="pending-meta">${detailParts.join(' • ')}</span>`;
          }
          if (note) {
            snapshotHtml += `<br><span class="pending-note-inline">Note: ${escapeHtml(note)}</span>`;
          }
          currentSnapshot.innerHTML = snapshotHtml;
        }
        if (sourceInput && sourceInput.value !== option.value) {
          sourceInput.value = option.value;
        }
        if (pendingContext) {
          pendingContext.active_source = option.value;
        }
        updatePendingStatusHint();
      }

      function updatePendingStatusHint() {
        if (!pendingStatusHint) {
          return;
        }
        if (pendingContext && pendingContext.has_pending) {
          pendingStatusHint.textContent = pendingContext.options && pendingContext.options.length
            ? 'Default selection is your newest draft. Choose another to review older edits, or pick “Start fresh from nets.json” to begin a new list.'
            : 'Drafts detected. Use the menu to review or switch between drafts.';
        } else {
          pendingStatusHint.textContent = 'New drafts start from nets.json until you create one.';
        }
      }

      function selectedSourceOption() {
        if (!sourcePicker) {
          return null;
        }
        return sourcePicker.selectedOptions[0] || null;
      }

      function escapeHtml(value) {
        return String(value ?? '').replace(/[&<>"']/g, (char) => {
          switch (char) {
            case '&':
              return '&amp;';
            case '<':
              return '&lt;';
            case '>':
              return '&gt;';
            case '"':
              return '&quot;';
            case "'":
              return '&#39;';
            default:
              return char;
          }
        });
      }

      function renderNetIndex(items) {
        if (!netList) {
          return;
        }
        const previousSelection = netList.value;
        netList.innerHTML = '';
        if (!items.length) {
          netList.disabled = true;
          updateNetListStatus(0);
          syncLoadSelectedButton();
          return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          const option = document.createElement('option');
          option.value = item.id;
          option.textContent = netOptionLabel(item);
          option.dataset.label = item.label || item.id;
          option.dataset.category = item.category || '';
          fragment.appendChild(option);
        });
        netList.appendChild(fragment);
        netList.disabled = false;

        let desiredValue = '';
        if (editingState.active && editingState.originalId) {
          desiredValue = editingState.originalId;
        } else if (previousSelection) {
          const exists = items.some((item) => (item.id || '').toLowerCase() === previousSelection.toLowerCase());
          if (exists) {
            desiredValue = previousSelection;
          }
        }
        if (desiredValue) {
          netList.value = desiredValue;
          if (netList.value !== desiredValue) {
            netList.selectedIndex = -1;
          }
        }
        if (netList.selectedIndex === -1 && netList.options.length) {
          netList.selectedIndex = 0;
        }

        updateNetListStatus(items.length);
        updateNetSelectionUI();
        syncLoadSelectedButton();
      }

      function applyNetSearch({ announceResults = false } = {}) {
        if (!netSearchInput) {
          filteredNetIndex = netIndex.slice();
          renderNetIndex(filteredNetIndex);
          return;
        }
        const query = netSearchInput.value.trim().toLowerCase();
        if (!query) {
          filteredNetIndex = netIndex.slice();
        } else {
          filteredNetIndex = netIndex.filter((item) => {
            const id = (item.id || '').toLowerCase();
            const name = (item.name || '').toLowerCase();
            return id.includes(query) || name.includes(query);
          });
        }
        renderNetIndex(filteredNetIndex);
        if (!filteredNetIndex.length && netIndex.length) {
          updateNetListStatus(0, 'No nets match your filter.');
        }
        if (announceResults) {
          const count = filteredNetIndex.length;
          const message = count === 1 ? '1 net matches your filter.' : `${count} nets match your filter.`;
          announce(message);
        }
      }

      async function loadNetIndex(sourceKey) {
        if (!netList) {
          return;
        }
        netList.setAttribute('aria-busy', 'true');
        netList.disabled = true;
        updateNetListStatus(0, 'Loading nets…');
        syncLoadSelectedButton();
        try {
          const url = new URL(buildApiUrl('api/nets'));
          if (sourceKey) {
            url.searchParams.set('source', sourceKey);
          }
          const response = await fetch(url.toString());
          const body = await parseResponse(response);
          if (!response.ok) {
            showStatus(body.error || 'Unable to load nets for editing.', 'error');
            netIndex = [];
            filteredNetIndex = [];
            renderNetIndex([]);
            updateNetListStatus(0, 'Unable to load nets.');
            return;
          }
          netIndex = Array.isArray(body.nets) ? body.nets : [];
          applyNetSearch();
        } catch (error) {
          showStatus(error.message, 'error');
          netIndex = [];
          filteredNetIndex = [];
          renderNetIndex([]);
          updateNetListStatus(0, 'Unable to load nets.');
        } finally {
          netList.removeAttribute('aria-busy');
          syncLoadSelectedButton();
        }
      }

      async function loadPendingOverview() {
        if (!pendingListContainer) {
          return;
        }
        pendingListContainer.setAttribute('aria-busy', 'true');
        try {
          const url = new URL(buildApiUrl('api/pending'));
          const activeSource = sourceInput ? sourceInput.value : pendingContext && pendingContext.active_source;
          if (activeSource) {
            url.searchParams.set('source', activeSource);
          }
          const response = await fetch(url.toString());
          const body = await parseResponse(response);
          if (!response.ok) {
            showStatus(body.error || 'Unable to load drafts for review.', 'error');
            renderPendingOverview({ pending_files: [] });
            updatePendingReviewToggle(0);
            return;
          }
          pendingContext.options = Array.isArray(body.options) ? body.options : pendingContext.options || [];
          pendingContext.has_pending = Boolean(body.pending_files && body.pending_files.length);
          pendingContext.permissions = body.permissions || pendingContext.permissions || {};
          pendingContext.user = body.user || pendingContext.user || '';
          pendingContext.pending = Array.isArray(body.pending_files) ? body.pending_files : [];
          if (body.active_source) {
            pendingContext.active_source = body.active_source;
          }
          updateSaveDraftState(pendingContext.active_source || 'nets');
          const pendingCount = pendingContext.pending.length;
          updatePendingReviewToggle(pendingCount);
          if (pendingReviewHint) {
            if (pendingContext.permissions && pendingContext.permissions.can_promote) {
              pendingReviewHint.textContent = 'Review drafts and publish them when you are ready.';
            } else {
              pendingReviewHint.textContent = 'Review drafts. A publisher will publish them after approval.';
            }
          }
          renderPendingOverview(body);
          refreshSourceOptions(pendingContext.options, pendingContext.active_source);
          updatePendingStatusHint();
          // no drafts to review
        } catch (error) {
          showStatus(error.message, 'error');
        } finally {
          pendingListContainer.removeAttribute('aria-busy');
        }
      }

      function refreshSourceOptions(options, activeKey) {
        if (!sourcePicker) {
          return;
        }
        const fragment = document.createDocumentFragment();
        let selectedKey = activeKey;
        if (!selectedKey && sourceInput && sourceInput.value) {
          selectedKey = sourceInput.value;
        }
        let hasSelected = false;
        options.forEach((option) => {
          const opt = document.createElement('option');
          opt.value = option.key;
          opt.textContent = option.label;
          opt.dataset.isPending = option.is_pending ? 'true' : 'false';
          opt.dataset.name = option.name || option.label || option.key;
          if (option.submitted_by) {
            opt.dataset.submittedBy = option.submitted_by;
          } else {
            opt.dataset.submittedBy = '';
          }
          if (option.submitted_at) {
            opt.dataset.submittedAt = option.submitted_at;
          } else {
            opt.dataset.submittedAt = '';
          }
          if (option.note) {
            opt.dataset.note = option.note;
          } else {
            opt.dataset.note = '';
          }
          if (!hasSelected && (option.active || option.key === selectedKey)) {
            opt.selected = true;
            hasSelected = true;
            selectedKey = option.key;
          }
          fragment.appendChild(opt);
        });
        sourcePicker.innerHTML = '';
        sourcePicker.appendChild(fragment);
        if (sourceInput) {
          if (hasSelected) {
            sourceInput.value = selectedKey;
          } else if (options.length) {
            sourceInput.value = options[0].key;
            selectedKey = options[0].key;
          }
        }
        if (pendingContext) {
          pendingContext.active_source = selectedKey || (options.length ? options[0].key : pendingContext.active_source);
        }
        updateSourceSelectionUI();
      }

      function renderPendingOverview(data) {
        if (!pendingListContainer) {
          return;
        }
        const files = Array.isArray(data.pending_files) ? data.pending_files : [];
        pendingContext.pending = files;
        const permissions = data.permissions || pendingContext.permissions || {};
        const canPromote = Boolean(permissions.can_promote);
        pendingListContainer.innerHTML = '';
        updatePendingReviewToggle(files.length);
        if (!files.length) {
          const empty = document.createElement('p');
          empty.className = 'pending-empty';
          empty.textContent = 'No drafts waiting for review.';
          pendingListContainer.appendChild(empty);
          if (pendingReviewSection) {
            pendingReviewSection.hidden = !pendingReviewVisible;
          }
          return;
        }
        files.forEach((file) => {
          const card = document.createElement('div');
          card.className = 'pending-card';
          card.dataset.key = file.key;

          const title = document.createElement('h3');
          title.textContent = file.label || file.name || file.key;
          card.appendChild(title);

          const meta = document.createElement('div');
          meta.className = 'meta';
          const statParts = [];
          const stats = file.stats || {};
          statParts.push(stats.added ? `${stats.added} added` : '0 added');
          statParts.push(stats.updated ? `${stats.updated} updated` : '0 updated');
          if (stats.removed) {
            statParts.push(`${stats.removed} removed`);
          }
          let submittedDisplay = '';
          const submittedAt = file.submitted_at || file.created_at || '';
          if (submittedAt) {
            const submittedDate = new Date(submittedAt);
            submittedDisplay = Number.isNaN(submittedDate.valueOf()) ? submittedAt : submittedDate.toLocaleString();
          }
          const metaParts = [];
          if (file.submitted_by) {
            metaParts.push(`Submitted by ${file.submitted_by}`);
          }
          if (submittedDisplay) {
            metaParts.push(submittedDisplay);
          }
          const statText = statParts.join(' • ');
          if (statText) {
            metaParts.push(statText);
          }
          meta.textContent = metaParts.join(' • ');
          card.appendChild(meta);

          const changes = Array.isArray(file.changes) ? file.changes : [];
          if (changes.length) {
            const list = document.createElement('ul');
            list.className = 'pending-change-list';
            const TYPE_LABELS = { added: 'Added', updated: 'Updated', removed: 'Removed' };
            const FIELD_LIMIT = 6;
            const formatDiffValue = (value) => {
              if (value === null || value === undefined || value === '') {
                return '—';
              }
              return String(value);
            };
            changes.forEach((change) => {
              const item = document.createElement('li');
              item.className = 'pending-change';
              const changeType = (change && change.type) || 'updated';
              const typeLabel = TYPE_LABELS[changeType] || 'Updated';
              const changeLabel = change.name ? `${change.id} — ${change.name}` : change.id || '';

              const head = document.createElement('div');
              head.className = 'pending-change-head';
              const title = document.createElement('span');
              title.className = 'pending-change-title';
              title.textContent = changeLabel ? `${typeLabel}: ${changeLabel}` : typeLabel;
              head.appendChild(title);
              const loadId = change.load_id;
              if (loadId) {
                const loadBtn = document.createElement('button');
                loadBtn.type = 'button';
                loadBtn.className = 'secondary pending-change-open';
                loadBtn.dataset.loadId = loadId;
                loadBtn.textContent = 'Open in editor';
                head.appendChild(loadBtn);
              }
              item.appendChild(head);

              const metaParts = [];
              if (change.category) {
                metaParts.push(String(change.category).toUpperCase());
              }
              if (change.start_local) {
                metaParts.push(`starts ${change.start_local}`);
              }
              if (change.time_zone) {
                metaParts.push(change.time_zone);
              }
              if (metaParts.length) {
                const metaLine = document.createElement('div');
                metaLine.className = 'pending-change-meta';
                metaLine.textContent = metaParts.join(' • ');
                item.appendChild(metaLine);
              }

              const fieldDiffs = Array.isArray(change.field_diffs) ? change.field_diffs : [];
              if (fieldDiffs.length) {
                const diffList = document.createElement('ul');
                diffList.className = 'pending-diff-list';
                fieldDiffs.slice(0, FIELD_LIMIT).forEach((diff) => {
                  const diffItem = document.createElement('li');
                  diffItem.className = 'pending-diff';
                  const fieldCode = document.createElement('code');
                  fieldCode.textContent = diff.field || '(field)';
                  diffItem.appendChild(fieldCode);
                  let description;
                  const beforeValue = formatDiffValue(diff.before);
                  const afterValue = formatDiffValue(diff.after);
                  if (diff.status === 'added') {
                    description = `added ${afterValue}`;
                  } else if (diff.status === 'removed') {
                    description = `removed (was ${beforeValue})`;
                  } else {
                    description = `${beforeValue} -> ${afterValue}`;
                  }
                  diffItem.appendChild(document.createTextNode(`: ${description}`));
                  diffList.appendChild(diffItem);
                });
                const remaining = fieldDiffs.length - FIELD_LIMIT;
                if (remaining > 0) {
                  const moreItem = document.createElement('li');
                  moreItem.className = 'pending-diff-more';
                  moreItem.textContent = `…${remaining} more field${remaining === 1 ? '' : 's'}`;
                  diffList.appendChild(moreItem);
                }
                item.appendChild(diffList);
              } else {
                const noFieldDiffs = document.createElement('p');
                noFieldDiffs.className = 'pending-empty';
                noFieldDiffs.textContent = 'No field-level differences recorded for this draft.';
                item.appendChild(noFieldDiffs);
              }

              list.appendChild(item);
            });
            card.appendChild(list);
          } else {
            const noChanges = document.createElement('p');
            noChanges.className = 'pending-empty';
            noChanges.textContent = 'No differences detected in this draft.';
            card.appendChild(noChanges);
          }

          if (file.note) {
            const note = document.createElement('p');
            note.className = 'pending-note';
            note.textContent = `Note: ${file.note}`;
            card.appendChild(note);
          }

          if (canPromote) {
            const actions = document.createElement('div');
            actions.className = 'actions';
            const promoteBtn = document.createElement('button');
            promoteBtn.type = 'button';
            promoteBtn.className = 'primary';
            promoteBtn.dataset.action = 'promote';
            promoteBtn.dataset.key = file.key;
            promoteBtn.textContent = 'Publish to live';
            actions.appendChild(promoteBtn);
            card.appendChild(actions);
          }

          pendingListContainer.appendChild(card);
        });
        if (pendingReviewSection) {
          pendingReviewSection.hidden = !pendingReviewVisible;
        }
      }

      async function promotePending(key) {
        if (!key) {
          return;
        }
        const entries = pendingContext.pending || [];
        const file = entries.find((entry) => entry.key === key);
        let summaryLines = [];
        const TYPE_LABELS = { added: 'Added', updated: 'Updated', removed: 'Removed' };
        if (file && Array.isArray(file.changes) && file.changes.length) {
          summaryLines = file.changes.map((change) => {
            const typeLabel = TYPE_LABELS[change.type] || 'Updated';
            const namePart = change.name ? ` — ${change.name}` : '';
            return `• ${typeLabel}: ${change.id || ''}${namePart}`.trim();
          });
        }
        if (!summaryLines.length && file && file.stats) {
          const stats = file.stats;
          summaryLines.push(`• Changes: added ${stats.added || 0}, updated ${stats.updated || 0}, removed ${stats.removed || 0}`);
        }
        if (!summaryLines.length) {
          summaryLines.push('• No detailed change list available');
        }
        const confirmMessage = `Publish this draft to live and push to GitHub?\n\n${summaryLines.join('\n')}\n\nThis updates _data/nets.json and creates a git commit.`;
        const confirmed = window.confirm(confirmMessage);
        if (!confirmed) {
          announce('Publish cancelled.');
          return;
        }

        clearStatus();
        showStatus('Publishing draft…');
        try {
          const response = await fetch(buildApiUrl('api/pending/promote_commit'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key }),
          });
          const body = await parseResponse(response);
          if (!response.ok) {
            showStatus(body.error || 'Unable to publish draft.', 'error');
            return;
          }
          let message = body.message || 'Draft published and committed.';
          if (body.commit) {
            const commit = body.commit;
            if (commit.hash) {
              message += ` Commit ${commit.short_hash || commit.hash}: ${commit.message || ''}.`;
            }
            if (commit.push_message) {
              message += ` ${commit.push_message}`;
            }
          }
          showStatus(message, 'success');
          const activeSource = body.active_source || 'nets';
          updateActiveSource(activeSource);
          await loadPendingOverview();
        } catch (error) {
          showStatus(error.message, 'error');
        }
      }

      async function loadNetForEdit(netId) {
        if (!netId) {
          return;
        }
        clearStatus();
        if (netList) {
          netList.setAttribute('aria-busy', 'true');
        }
        syncLoadSelectedButton();
        try {
          const url = new URL(buildApiUrl(`api/nets/${encodeURIComponent(netId)}`));
          const sourceKey = sourceInput ? sourceInput.value : pendingContext && pendingContext.active_source;
          if (sourceKey) {
            url.searchParams.set('source', sourceKey);
          }
          const response = await fetch(url.toString());
          const body = await parseResponse(response);
          if (!response.ok) {
            showStatus(body.error || 'Unable to load that net for editing.', 'error');
            return;
          }
          const label = body.label || body.original_id || netId;
          applyFormState(body.net, { announceMessage: `${label} ready for editing.` });
        } catch (error) {
          showStatus(error.message, 'error');
      } finally {
        if (netList) {
          netList.removeAttribute('aria-busy');
        }
        syncLoadSelectedButton();
      }
    }

    function handleNetSearchLoad() {
      const typedValue = netSearchInput ? netSearchInput.value.trim() : '';
      if (typedValue) {
        loadNetForEdit(typedValue);
        return;
      }
      if (netList && netList.value) {
        loadNetForEdit(netList.value);
        return;
      }
      announce('Select a net from the list or enter an ID to load.');
      if (netList && !netList.disabled) {
        netList.focus({ preventScroll: true });
      } else if (netSearchInput) {
        netSearchInput.focus({ preventScroll: true });
      }
    }

    function clearStatus() {
      statusBox.hidden = true;
      statusBox.textContent = '';
      statusBox.className = 'status';
      statusBox.removeAttribute('role');
      statusBox.setAttribute('aria-live', 'polite');
      clearFieldErrors();
    }

      function prepareFormForNewNet({ announceMessage = null, focus = true } = {}) {
        form.reset();
        manualTimeMode = false;
        customFieldsContainer.innerHTML = '';
        if (sourceInput) {
          const activeSource =
            (pendingContext && pendingContext.active_source) ||
            (sourcePicker && sourcePicker.value) ||
            sourceInput.value;
          if (activeSource) {
            sourceInput.value = activeSource;
          }
        }
        if (modeInput) {
          modeInput.value = modeInput.defaultValue || 'add';
        }
        if (originalIdInput) {
          originalIdInput.value = '';
        }
        const defaultCategory = categoryRadios.find((radio) => radio.checked) || categoryRadios[0];
        if (defaultCategory) {
          handleCategoryChange(defaultCategory.value);
        } else {
          handleCategoryChange('');
        }
        const sourceHashInput = document.getElementById('source_hash');
        if (sourceHashInput) {
          sourceHashInput.value = '';
        }
        applyTimeZoneSelection(timeZoneSelect.value || '');
        updateTimeMode();
        updateBuilderVisibility();
        updateRruleDescription();
        connectionConfigs.forEach((config) => {
          if (!config.checkbox) return;
          config.checkbox.checked = false;
          clearConnectionFields(config);
          setConnectionState(config, false, {
            announceChanges: false,
            allowPrompt: false,
            initialize: true,
          });
        });
        if (idField) {
          idField.value = '';
        }
        updateIdDisplay('');
        autoAssignId({ force: true });
        if (announceMessage) {
          announce(announceMessage);
        }
        if (focus) {
          focusNameField();
        }
      }

      function resetFormAfterSave() {
        exitEditMode({ silent: true });
        clearDraft();
        prepareFormForNewNet({ announceMessage: 'Form cleared for the next net entry.' });
      }

      function focusNameField() {
        if (netNameInput) {
          netNameInput.focus({ preventScroll: true });
        }
      }

      function renderErrors(errorMap) {
        const entries = Object.entries(errorMap || {});
        if (!entries.length) {
          showStatus('There was a problem — please try again.', 'error');
          return;
        }
        let firstField = null;
        const messages = [];
        clearFieldErrors();
        for (const [name, message] of entries) {
          const field = markFieldError(name);
          if (!firstField && field && typeof field.focus === 'function') {
            firstField = field;
          }
          messages.push(message);
        }
        showStatus(messages.join(' '), 'error');
        if (firstField) {
          firstField.focus({ preventScroll: true });
          if (typeof firstField.scrollIntoView === 'function') {
            firstField.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }
        }
      }

      function showStatus(message, type = 'success') {
        statusBox.hidden = false;
        statusBox.textContent = message;
        statusBox.className = `status ${type}`;
        if (type === 'error') {
          statusBox.setAttribute('role', 'alert');
          statusBox.setAttribute('aria-live', 'assertive');
        } else {
          statusBox.setAttribute('role', 'status');
          statusBox.setAttribute('aria-live', 'polite');
        }
      }

      function announce(message) {
        showStatus(message, 'success');
      }

      function updateTimeMode(options = {}) {
        const { focus = false } = options;
        clearFieldError(startTimePicker);
        clearFieldError(startTimeManual);
        if (manualTimeMode) {
          const normalized = normalizeTime(startTimePicker.value);
          if (normalized) {
            startTimeManual.value = normalized;
          }
          startTimePicker.hidden = true;
          startTimePicker.setAttribute('aria-hidden', 'true');
          startTimePicker.required = false;
          startTimeManual.hidden = false;
          startTimeManual.removeAttribute('aria-hidden');
          startTimeManual.required = true;
          toggleTimeModeBtn.textContent = 'Use time picker';
          startTimeHint.textContent = 'Manual 24-hour entry is active. Type HH:MM such as 23:30.';
          toggleTimeModeBtn.setAttribute('aria-expanded', 'true');
          if (focus) {
            startTimeManual.focus();
          }
        } else {
          const normalizedManual = normalizeTime(startTimeManual.value);
          if (normalizedManual) {
            startTimePicker.value = normalizedManual;
          }
          startTimePicker.hidden = false;
          startTimePicker.removeAttribute('aria-hidden');
          startTimePicker.required = true;
          startTimeManual.hidden = true;
          startTimeManual.setAttribute('aria-hidden', 'true');
          startTimeManual.required = false;
          toggleTimeModeBtn.textContent = 'Use 24-hour entry';
          startTimeHint.textContent = 'Using the browser time picker. Your browser may show AM/PM or 24-hour format.';
          toggleTimeModeBtn.setAttribute('aria-expanded', 'false');
          if (focus) {
            startTimePicker.focus();
          }
        }
      }

      function updateBuilderVisibility() {
        const freq = builderFreq.value;
        const showWeekly = freq === 'WEEKLY';
        const showMonthly = freq === 'MONTHLY';
        weeklyOptions.hidden = !showWeekly;
        weeklyOptions.style.display = showWeekly ? '' : 'none';
        weeklyOptions.setAttribute('aria-hidden', showWeekly ? 'false' : 'true');
        monthlyOptions.hidden = !showMonthly;
        monthlyOptions.style.display = showMonthly ? '' : 'none';
        monthlyOptions.setAttribute('aria-hidden', showMonthly ? 'false' : 'true');
      }

      function updateRruleDescription() {
        const rule = rruleInput.value.trim();
        const netName = netNameInput.value.trim() || 'This net';
        const startTime = getCurrentStartTime();
        rruleDescription.textContent = describeRrule(rule, netName, startTime);
      }

      function getCurrentStartTime() {
        if (manualTimeMode) {
          return normalizeTime(startTimeManual.value) || '';
        }
        return normalizeTime(startTimePicker.value) || '';
      }

      function normalizeTime(value) {
        if (!value) return '';
        const trimmed = String(value).trim();
        if (!trimmed) return '';
        const match = trimmed.match(/^(\d{1,2})(:?)(\d{2})$/);
        if (!match) return '';
        let hours = parseInt(match[1], 10);
        const minutes = parseInt(match[3], 10);
        if (Number.isNaN(hours) || Number.isNaN(minutes)) return '';
        if (hours > 23 || minutes > 59) return '';
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
      }

      function describeRrule(rule, netName, startTime) {
        if (!rule) {
          return 'No RRULE provided yet.';
        }

        const pairs = {};
        for (const segment of rule.split(';')) {
          if (!segment.includes('=')) {
            return 'RRULE preview unavailable for this pattern.';
          }
          const [rawKey, rawValue] = segment.split('=');
          if (!rawKey || !rawValue) {
            return 'RRULE preview unavailable for this pattern.';
          }
          pairs[rawKey.toUpperCase()] = rawValue;
        }

        const freq = (pairs.FREQ || '').toUpperCase();
        if (!freq) {
          return 'RRULE preview unavailable for this pattern.';
        }

        const interval = Math.max(parseInt(pairs.INTERVAL, 10) || 1, 1);
        const everyText = interval > 1 ? `every ${interval} ${freq.toLowerCase()}s` : `every ${freq.toLowerCase()}`;
        const timeText = startTime ? ` at ${formatTime(startTime)}` : '';

        if (freq === 'DAILY') {
          return `${netName} repeats ${everyText}${timeText}.`;
        }

        if (freq === 'WEEKLY') {
          const daysRaw = pairs.BYDAY ? pairs.BYDAY.split(',') : [];
          if (!daysRaw.length) {
            return `${netName} repeats ${everyText}${timeText}.`;
          }
          const dayNames = daysRaw.map(code => weekdayName(code)).filter(Boolean);
          const list = formatList(dayNames);
          return `${netName} repeats ${everyText} on ${list}${timeText}.`;
        }

        if (freq === 'MONTHLY') {
          if (pairs.BYMONTHDAY) {
            const day = pairs.BYMONTHDAY;
            return `${netName} repeats ${everyText} on day ${day} of the month${timeText}.`;
          }
          if (pairs.BYDAY && pairs.BYSETPOS) {
            const weekdayTokens = pairs.BYDAY.split(',').map((token) => token.trim()).filter(Boolean);
            const setPositions = pairs.BYSETPOS.split(',').map((token) => parseInt(token, 10)).filter((value) => !Number.isNaN(value));
            if (setPositions.length) {
              if (weekdayTokens.length === 1) {
                const weekday = weekdayName(weekdayTokens[0]);
                if (weekday) {
                  const labels = setPositions.map((pos) => positionName(pos)).filter(Boolean);
                  if (labels.length) {
                    const posText = formatList(labels);
                    return `${netName} repeats ${everyText} on the ${posText} ${weekday}${timeText}.`;
                  }
                  return `${netName} repeats ${everyText} on ${weekday}${timeText}.`;
                }
              } else {
                const weekdayLabels = weekdayTokens.map((token) => weekdayName(token)).filter(Boolean);
                if (weekdayLabels.length === setPositions.length && weekdayLabels.length) {
                  const combos = setPositions
                    .map((pos, index) => {
                      const posLabel = positionName(pos);
                      const weekday = weekdayLabels[index];
                      if (!posLabel || !weekday) {
                        return null;
                      }
                      return `the ${posLabel} ${weekday}`;
                    })
                    .filter(Boolean);
                  if (combos.length) {
                    const comboText = formatList(combos);
                    return `${netName} repeats ${everyText} on ${comboText}${timeText}.`;
                  }
                }
              }
              const weekdayFallback = weekdayTokens.map((token) => weekdayName(token)).filter(Boolean);
              if (weekdayFallback.length) {
                const fallbackText = formatList(weekdayFallback);
                return `${netName} repeats ${everyText} on ${fallbackText} each month${timeText}.`;
              }
            }
          }
          return `${netName} repeats ${everyText}${timeText}.`;
        }

        return 'RRULE preview unavailable for this pattern.';
      }

      function weekdayName(code) {
        const normalized = String(code || '').toUpperCase().slice(-2);
        const map = {
          MO: 'Monday',
          TU: 'Tuesday',
          WE: 'Wednesday',
          TH: 'Thursday',
          FR: 'Friday',
          SA: 'Saturday',
          SU: 'Sunday',
        };
        return map[normalized] || '';
      }

      function ordinalSuffix(value) {
        const abs = Math.abs(value);
        const mod100 = abs % 100;
        if (mod100 >= 11 && mod100 <= 13) {
          return 'th';
        }
        switch (abs % 10) {
          case 1:
            return 'st';
          case 2:
            return 'nd';
          case 3:
            return 'rd';
          default:
            return 'th';
        }
      }

      function positionName(value) {
        switch (value) {
          case 1:
            return 'first';
          case 2:
            return 'second';
          case 3:
            return 'third';
          case 4:
            return 'fourth';
          case 5:
            return 'fifth';
          case 6:
            return 'sixth';
          case -1:
            return 'last';
          case -2:
            return 'second to last';
          case -3:
            return 'third to last';
          default:
            if (Number.isInteger(value) && value > 0) {
              return `${value}${ordinalSuffix(value)}`;
            }
            if (Number.isInteger(value) && value < 0) {
              const positive = Math.abs(value);
              return `${positive}${ordinalSuffix(positive)} to last`;
            }
            return null;
        }
      }

      function formatList(items) {
        if (!items.length) return '';
        if (items.length === 1) return items[0];
        return `${items.slice(0, -1).join(', ')} and ${items[items.length - 1]}`;
      }

      function formatTime(value) {
        const [h, m] = value.split(':').map(Number);
        if (Number.isNaN(h) || Number.isNaN(m)) {
          return value;
        }
        const period = h >= 12 ? 'PM' : 'AM';
        const hour12 = ((h + 11) % 12) + 1;
        const paddedMinutes = String(m).padStart(2, '0');
        return `${hour12}:${paddedMinutes} ${period}`;
      }
    </script>
  </body>
</html>
